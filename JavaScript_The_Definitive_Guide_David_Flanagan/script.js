console.log("Hello World!");

//------------------------------------
//______Лексическая структура______//

//____Текст программы JavaScript
//язык, чувствительный к регистру символов

//____Комментарии
// Это однострочный комментарий
/*
 * Это многострочный комментарий. Добавочные символы * в начале каждой
 * строки не являются обязательной частью синтаксиса;
 * просто они классно выглядят!
 */

//____Литералы
//значение данных, находящееся прямо в программе
12; // Число двенадцать
1.2; // Число одна целая и две десятых
("hello world"); // Строка текста
("Hi"); // Еще одна строка
true; // Булевское значение
false; // Другое булевское значение
null; // Отсутствие объекта

//____Идентификаторы и зарезервированные слова
//это просто имя ,для именования констант, переменных, свойств, функций и классов.

//____Зарезервированные слова
//вроде if , while и for...

//____Unicode
//математические символы и слова
const n = 3.14;
const si = true;

//___Необязательные точки с запятой
//всегда можете опускать точку с запятой между двумя операторами, если они записаны в отдельных строках
а = 3;
b = 4;
а = 3;
b = 4;

//Защитная ; сохраняет этото ператор отдельным
[х, х + 1, х + 2].forEach(console.log);

//разрыв строки
//return , throw, yield , break и continue

//------------------------------------
//___Типы, значения и переменные____//
//элементарные типы и объектные типы
//Объектные типы JavaScript являются изменяемыми, элементарные типы — неизменяемыми.
//Константы объявляются с помощью co n st, а переменные посредством let(или var в более старом коде JavaScript).

//___Числа
//Number
О;
3;
10000000;

//шестнадцатеричных целочисленных литералов
Oxff; // => 255: (15*16 + 15)
OxBADCAFE; // => 195939070

//целые числа можно также выражать в двоичном (с основанием 2) или восьмеричном (с основанием 8) виде с применением префиксов 0Ь и Оо(или 0В и 00) вместо Ох
0b0101; // => 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
0o377; // => 255: (3*64 + 7*8 + 7*1)

3.14;
2345.6789;
0.333333333333333333;
6.02e23; // 6.02 х 1023
1.4738223e-32; // 1.4738223 х 10'32

//числовых литералах можно применять подчеркивания, чтобы разбивать их на порции
let billion = 1_000_000_000; // Подчеркивание как разделитель тысяч,
let bytes = 0x89_ab_cd_ef; // Подчеркивание как разделитель байтов,
let bits = 0b0001_1101_0111; //Подчеркивание как разделитель полубайтов,
let fraction = 0.123_456_789; // Работает и в дробной части.

//____ Арифметические действия
Math.pow(2, 53); // => 9007199254740992: 2 в степени 53
Math.round(0.6); // => 1.0: округляет до ближайшего целого
Math.ceil(0.6); // => 1.0: округляет в большую сторону до целого
Math.floor(0.6); // => 0.0: округляет в меньшую сторону до целого
Math.abs(-5); // => 5: абсолютная величина
Math.max(x, y, z); // Возвращает наибольший аргумент
Math.min(x, y, z); // Возвращает наименьший аргумент
Math.random(); // Псевдослучайное число х, где 0 <= х < 1.0
Math.PI; // п: длина окружности, деленная на диаметр
Math.E; // е: основание натурального логарифма
Math.sqrt(3); // => 3**0.5: квадратный корень из 3
Math.pow(3, 1 / 3); // => 3** (1/3) : кубический корень из 3
Math.sin(0); // Тригонометрия: также есть Math.cos, Math.atan и т.д.
Math.log(10); // Натуральный логарифм 10
Math.log(100); // Math.LN10 // Десятичный логарифм 100
Math.log(512); // Math.LN2 // Двоичный логарифм 512
Math.exp(3); // Math.E в кубе
//...

//не генерируют ошибки  а возврощает Infinity
1 / 0 - // => Infinity
  1 / 0; // => -Infinity
0 / 0; // => NaN

Number.parselnt(); // То же, что и глобальная функция parselnt
Number.parseFlot();
Number.isNaN(x); // Является ли х значением NaN?
Number.isFinite(x); // Является ли х конечным числом?
Number.islnteger(x); // Является ли х целым числом?
Number.isSafelnteger(х); // Является ли х целым числом -(2**53) < х < 2**

//число не может быть представлено точно
let х = 0.3 - 0.2; // тридцать центов минус двадцать центов
let у = 0.2 - 0.1; // двадцать центов минус десять центов
х === 0.1; // => false: .3-.2 не равно Л

//___Bigint
1234n;
Bigint(Number.MAX_SAFE_INTEGER); // => 9007199254740991n

//Арифметические действия -подобно арифметическим действиям но при деление отбрасывает любой остаток и округляет в меньшую сторону
//смешивать операнды типа Bigintс обычными числовыми операндами нельзя.
//Напротив, операции сравнения работают со смешанными числовыми типами
1000n + 2000n; //=> ЗОООп
1 < 2n; // => true

//___ Дата и время
let timestamp = Date.nowO; //Текущее время как отметка времени (число) .
let now = new Date(); // Текущее время как объект Date.
let ms = now.getTime(); // Преобразовать в миллисекундную отметку времени.
let iso = now.toISOString(); // Преобразовать в строку со стандартным форматом.

//___Текст
// строки являются итерируемымые
// "" '' ``
(""); // Пустая строка: содержит ноль символов
("testing");
("3.14");
('name="myform" ');
("Wouldn’t you prefer 0*Reilly's book?");
"n is the ratio of a circle's circumference to its radius"`"She said 'hi'", he said.`;

// Строка, представляющая две строки, которые записаны в одной строке:
("two\nlines ");

// Однострочная строка, записанная в трех строках:
"опе\
long\
line" // Двухстрочная строка, записанная в двух строках:
`the newline character at the end of this line
is included literally in this string`;

//<button onclick="alert ('Thank you') ">Click Me</button>

//экранирование
("YouVre right, it can*t be a quote");

//\u{1f600} — эмотикон ухмыляющаяся рожица

//конкатенации строк
let msg = "Hello, " + "world"; // Образует строку "Hello, world"

//Строки можно сравнивать с помощью стандартных операций равенств

let s = "Hello, world"; // Начать с некоторого текста.
s.length;
s.substring(l, 4); // => "ell": 2 - й, 3 - й и 4 - й символы
s.slice(1, 4); // => "ell": то же самое
s.slice(-3); // => "rid": последние 3 символа
s.split(", "); // => ["Hello", "world"]: разбивает по строке разделителя
s.indexOf("1"); // => 2: позиция первой буквы
s.lastlndexOf("1"); // => 10: позиция последней буквы 1
s.startsWith("Hell"); // => true: строка начинается с этого
s.endsWith("!"); // => false: s не оканчивается этим
s.includes("or"); // => true: s включает подстроку "or"
s.replace("Но", "уа"); // => "Heya, world"
s.toLowerCase(); // => "hello, world"
s.toUpperCase(); // => "HELLO, WORLD"
s.charAt(0); // => "Н": первый символ
s.charAt(s.length - 1); // => "d": последний символ
"х".padStart(3); // => " х": добавляет пробелы слева до длины 3
"test".trim(); // => "test” : удаляет пробелы в начале и конце
s.concat("!"); // => "Hello, world!” : взамен просто используйте операцию +
"о".repeat(5); // => "<><><><><>” : выполняет конкатенацию

//Не забывайте, что строки в JavaScript неизменяемы,возвращают новые строки: они не модифицируют строку

let s = "hello, world";
s[0]; // => "h”
s[s.length - 1]; // => "d"

//Шаблонные литералы
let name = "Bill";
let greeting = `Hello ${name}.`; // greeting == "Hello Bill

//____регулярные выражение
let text = "testing: 1, 2, 3";
let pattern = /\d+/g;
pattern.test(text); // => true: есть совпадение

//___Булевские значения
//true и false

// false
//undefined null 0 -0 NaN ""// пустая строка

//Все остальные значения true

//Операция && выполняет булевскую операцию "И"
//Операция | | — это булевская операция “ИЛИ”
//! выполняет булевскую операцию НЕ
if ((х === 0 && у === 0) || !(z === 0)) {
  // х и у равны нулю или z не равно нулю
}

//___null и undefined
//null - отсутствие значения
//undefine - не были инициализированы, и то, что получается при запрашивании значений свойств объекта или элементов массива, которые не существуют

//__Тип Symbol
//Чтобы получить значение символа, понадобится вызвать функцию Symbol (), которая никогда не возвращает то же самое значение дважды, даже когда вызывается с таким же аргументом.
let strname = "string name";
let symname = Symbol("propname");
let о = {};
о[strname] = 1;
о[strname]; // => 1: доступ к свойству со строковым именем

toString(); //— единственный интересный метод в экземплярах Symbol
let s = Symbol("sym_x");
s.toString(); // => "Symbol(sym_x) "

//Symbol.for() всегда возвращает то же самое значение
let s = Symbol.for("shared");
let t = Symbol.for("shared");
s === t; // => true
s.toString(); // => "Symbol (shared) "
Symbol.keyFor(t); // => "shared"

//__ Глобальный объект
//его свойствами являются глобально определенные идентификаторы, доступные программе JavaScript
//Node - global
//Window
//ссылки на глобальный объект - globalThis

//___Неизменяемые элементарные значения и изменяемые объектные ссылки
//Элементарные значения неизменяемый
//Объекты отличаются от элементарных значений. Прежде всего, они изменяемы — их значения можно модифицировать
let о = { х: 1 };
о.х = 2;
о.у - 3;
let а = [1, 2, 3];
а[0] = 0;
а[3] = 4;

let о = { х: 1 },
  р = { х: 1 }; // Два объекта с одинаковыми свойствами
о === р; // => false: отдельные объекты никогда не равны

// объекты называют ссылочными типами они ссылаются на тот же самый внутренний объект
let а = []; // Переменная а ссылается на пустой массив
let b = а; // Теперь на тот же самый массив ссылается переменная b
b[0] = 1; // Изменить массив, на который ссылается переменная b
а[0]; // => 1: изменение также будет видимым через переменную а
а === b; // => true: а и b ссылаются на тот же самый объект,поэтому они равны

//Если вы хотите создать новую копию объекта или массива, тогда должны явно скопировать свойства объекта или элементы массива
let a = ["а", "b", "с"]; // Массив, который мы хотим скопировать
let b = []; // Отдельный массив, куда м ы будем копировать
for (let i = 0; i < a.length; i++) {
  // Для каждого из всех индексов
  b[i] = a[i]; // Копировать элемент а в b
}

let с = Array.from(b); //В ES6 копируйте массивы с помощью Array.from()

function equalArrays(а, b) {
  if (а === b) return true; // Идентичные массивы равны
  if (a.length !== b.length) return false; //Массивы разного размера
  //не равны
  for (let i = 0; i < a.length; i++) {
    //Цикл по всем элементам
    if (a[i] !== b[i]) return false; //Если любые элементы отличаются,
    //то массивы не равны
  }
  return true; // Иначе они равны
}

//___Преобразования типов
"7" + "4"; //11
10 + " objects"; // => ”10 objects": число 10 преобразуется в строку

//___Преобразования и равенство
null == undefined; //=> true: эти два значения трактуются как равные,
"0" == 0; //=> true перед сравнением строка преобразуется в число.

//___Явные преобразование
Number("3"); // => 3
String(false); // => "false"
Boolean([]); // => true

let n = 17;
let binary = "Ob" + n.toString(2); // binary == "OblOOOl

let n = 123456.789;
n.toFixed(0); // => "123457"

//___неявное преобразование
х +
  "" + // => String(х)
  х; // => Number (х)
х - 0; // => Number (х)
!!х; // => Boolean(х) : обратите внимание на два символа !

parselnt("-12.34"); // => -12
parseFloat(" .1")(
  // = > 0.1

  //___ Преобразования объектов в элементарные значения
  //prefer-string toString() /  prefer-number valueOf() /  no-preference
  { х: 1, у: 2 }
).toString(); // => "[object Object]”
let d = new Date(2010, 0, 1); //1 января 2010 года (тихоокеанское время)
d.valueOf(); // => 126233280

//___Объявление и присваивание переменных
// let / const
//const только для значений, которые не должны изменяться
let i = 0,
  j = 0,
  k = 0;

//Переменные и константы, объявленные с помощью let и const, имеют блочную область видимости(if / else /while / for)
const х = 1; //О бъявить х как глобальную константу
if (х === 1) {
  let х = 2; //В н утр и блока х может ссылаться на другое значение
  console.log(х); // Выводится 2
}
console.log(х); //В ы водится 1: мы снова вернулись  в глобальную область видимости
let х = 3; //ОШИБКА! Синтаксическая ошибка при попытке
//п о в т о р н о го объявления х

//var
//функциональная видимость

//___Деструктурирующее присваивание
let [х, у] = [1, 2]; // То же, что и l e t х = 1, у = 2
[X, у] = [х + 1, у + 1]; // То же, что и х = х + 1, у = у + 1

let о = { х: 1, у: 2 }; // Объект, по которому будет
// делаться проход в цикле
for (const [nаше, value] of Object.entries(о)) {
  console.log(nаше, value);
}

let [х, у] = [1]; // х == 1; у == u n d efin ed
[х, у] = [1, 2, 3]; // х == 1; у == 2

let [х, ...у] = [1, 2, 3, 4]; // у == [2, 3, 4]

let [а, [Ь, с]] = [1, [2, 2.5], 3]; // а == 1; b == 2; с ==

let [first, ...rest] = " Hello ";

let transparent = { г: 0.0, g: 0.0, b: 0.0, а: 1.0 }; // Цвет RGBA
let { г, g, b } = transparent; // г = 0 .0; g == 0 .0; b == 0 .0

const sin = Math.sin,
  cos = Math.cos,
  tan = Math.tan;
const { sin, cos, tan } = Math;

const { cos: cosine, tan: tangent } = Math;

let points = [
  { х: 1, у: 2 },
  { х: 3, у: 4 },
];
let [{ х: x1, у: у1 }, { х: х2, у: у2 }] = points;

//----------------------------------------
//_________Выражения и операции________//
//синтаксическая конструкция JavaScript

//___Первичные выражения
//константы или литеральные значения,ссылку на переменную, this
("hello"); // Строковый литерал
true; // Вычисляется как булевское истинное значение

//___Инициализаторы объектов и массивов
//созданные объекты или массивы, разделяемый запятыми список выражений
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

//___Выражения определений функций
//защититься от ошибок

//“литералом функции"
let square = function (х) {
  return х * х;
};

//___Выражения доступа к свойствам
//[],.

//___Условный доступ к свойствам
let а = { b: null };
a.b?.c?.d; // => undefined

//___Выражения вызова
a.sort();
Math.max(x, y, z);
f(0);

//___Условный вызов
о?.m(); // Условный доступ к свойству, обыкновенный вызов

//___Выражения создания объектов
new Object();

//___Обзор операций
//большинство  + и =
//некоторые delete и instanceof
//ассоциативность операций — слева направо или справа налево

//___Количество операндов
// бинарными операциямиу которые объединяет два выражения * / ...
//унарных операций ++
//тернарная операция _ ? _ : _

//___Побочные эффекты операций
//операции присваивания , ++_, _++ , delete

//___Приоритеты операций
//Интерпретатор JavaScript всегда вычисляет выражения строго в порядке слева направо

//___Арифметические выражения
//Базовыми арифметическими операциями являются ** (возведение в степень), * (умножение), / (деление), % (модуль: остаток от деления), + (сложение) и - (вычитание)

//___Операция +
1 + 2; // => 3
"hello" + " " + "there"; // => "hello there"
"1" + "2"; // => "12"

//___Унарные арифметические операции
//модифицируют значение единственного операнда

//___Побитовые операции
//низкоуровневые манипуляции битами в двоичном представлении чисел
// & | ~ << >>

//___Операции равенства и неравенства
//== и == !==..

//___Операции сравнения
// <= => > <

//___Операция in
//tr u e , если значением с левой стороны будет имя свойства объекта с правой стороны
let point = { х: 1, у: 1 };
"х" in point; //=> true

//___Операция instanceof
//экземпляром класса
let d = new Dated(); //Создание нового объекта с помощью конструктора Dated
d instanceof Date; // => true

//___Логические выражения
// &&, | | и !
х === 0 && у === 0; // true, если и только если х и у равны 0
let max = maxWidth || preferences.maxWidth || 500;
!х; //х ложное равно true

//___Выражения присваивания
i = j = k = 0; // Инициализация трех переменных значением

//___Присваивание с действием
total += salesTax;

//___Вычисление выражений
eval("3+2"); // => 5

//___Смешанные операции
х > 0 ? х : -х; // Абсолютное значение х

//если левый операнд не является n u ll или undefined
let options = {
  timeout: 0,
  title: "",
  verbose: false,
  n: null,
};
options.timeout ?? 1000; // => 0: как определено в объекте

//Операция typeof
typeof value === "string";

//Операция delete
let о = { х: 1, у: 2 };
delete о.х;

//Операция await
//асинхронное программирование

//Операция void
//отбрасывает значение и возвращает undefined.
let counter = 0;
const increment = () => void counter++;
increment(); // => undefined

//Операция "запятая"
(i = 0), (j = l), (k = 2);

//--------------------------------------
//_____________Операторы______________//

//___Операторы-выражения
counter++;
console.log();
Math.cos();

//___Составные и пустые операторы
{
  //...
}

//___if
if (n === 1) {
  // Выполнить блок кода #1
} else if (n === 2) {
  // Выполнить блок кода #2
} else if (n === 3) {
  // Выполнить блок кода #3
} else {
  // Если ни одна из конструкций else не выполнилась, тогда выполнить блок кода #4
}

//___switch
switch (key) {
  case value:
    break;

  default:
    break;
}

//___ Циклы

//while
let count = 0;
while (count < 10) {
  console.log(count);
  count++;
}

//do/while
//тело цикла всегда выполняется, по крайней мере, один раз
do {
  console.log(a[i]);
} while (++i < len);

//for
for (let index = 0; index < array.length; index++) {
  const element = array[index];
}

//for / of
//работает с итерируемыми объектами
let data = [1, 2, 3, 4, 5, 6, 7, 8, 9],
  sum = 0;
for (let element of data) {
  sum += element;
}
sum; // => 45

//for / of с объектами
let о = { х: 1, у: 2, z: 3 };
let keys = "";
for (let k of Object.keys(o)) {
  keys += k;
}
keys; // => "xyz"

let sum = 0;
for (let v of Object.values(о)) {
  sum += v;
}
sum; // => 6

let pairs = "";
for (let [k, v] of Object.entries(o)) {
  pairs += k + v;
}
pairs; // => "xly2z3"

//for / of со строками
let frequency = {};
for (let letter of "mississippi") {
  if (frequency[letter]) {
    frequency[letter]++;
  } else {
    frequency[letter] = 1;
  }
}
frequency; // => {m: 1, i: 4, s: 4, p: 2}

//for/of с классами Set и Мар
let text = "Na па па па па па па па Batman!";
let wordSet = new Set(text.split(" "));
let unique = [];
for (let word of wordSet) {
  unique.push(word);
}
unique; // => ["Na", "na", "Batman!"]

let m = new Map([[1, "one"]]);
for (let [key, value] of m) {
  key; // => 1
  value; // => "one"
}

//Асинхронная итерация с помощью for/await
async function printStream(stream) {
  for await (let chunk of stream) {
    console.log(chunk);
  }
}

//for/in
//работает с любым объектом
for (let р in о) {
  // Присвоить имена свойств объекта о переменной р
  console.log(о[р]); // Вывести значение каждого свойства
}

let о = { х: 1, у: 2, z: 3 };
let а = [],
  i = 0;
for (a[i++] in о /* пустое тело */);

//___Переходы
// break , continue, return, yield, throw, try/catch/finally

mainloop: while (token !== null) {
  // Код опущен...
  continue mainloop; //Перейти к следующей итерации именованного цикла
  // Код опущен__
}

function square(х) {
  return х * х;
} // Функция, которая имеет
// оператор return
square(2); // => 4

//yield во многом похож на return
// Генераторная функция, которая выдает диапазон целых чисел
function* range(from, to) {
  for (let i = from; i <= to; i++) {
    yield i;
  }
}

//throw
//Генерация исключения

//try / catch / finally:
try {
  // В нормальной ситуации этот код выполняется от начала до конца блока
  // безо всяких проблем. Но иногда он может генерировать исключение,
  // либо напрямую с помощью оператора throw, либо косвенно за счет вызова
  // метода, который генерирует исключение.
} catch (е) {
  // Операторы в данном блоке выполняются, если и только если в блоке try
  // было сгенерировано исключение. Эти операторы могут использовать
  // локальную переменную е для ссылки на объект Error или другое значение,
  // которое было указано в throw. В блоке можно каким-то образом
  // обработать исключение, проигнорировать его, ничего не делая,
  // или повторно сгенерировать исключение с помощью throw.
} finally {
  // Данный блок содержит операторы, которые всегда выполняются
  // независимо от того, что произошло в блоке try.
  // Они выполняются при завершении блока try:
  // 1) нормальным образом после того, как достигнут конец блока;
  // 2) из-за оператора break, continue или return;
  // 3) из-за исключения, которое было обработано конструкцией catch выше;
  // 4) из-за необработанного исключения, которое продолжило
  // свое распространение.
}

//___Смешанные операторы
//with , debugger и "use strict"

//with применяется для облегчения работы с глубоко вложенными иерархиями объектов
document.forms[0].address.value;
//обычно
let f = document.forms[0];
f.name, (value = "");
f.address.value = "";
f.email, (value = "");
//c with
with ((document, forms[0])) {
  // Далее появляется возможность прямого доступа к элементам формы,
  // например:
  name.value = "";
  address.value = "";
  email.value = "";
}

//debugger
function f(о) {
  if (о === undefined) debugger; //Временная строка для отладочных целей
  //Далее идет остальной код функции
}

//"use strict"
//В строгом режиме оператор w ith не разрешен
//В строгом режиме все переменные должны быть объявлены
//функции -> this = равное undefined
//не поддерживающим запись свойствам -> ТуреЕггог
//объект arguments ->  статическую копию значений
//генерации ошибки ТуреЕггог

//___Объявления
//const, let , var, function , class , import и export
const TAU = 2 * Math.PI;
let radius = 3;
var circumference = TAU * radius;

function area(radius) {
  return Math.PI * radius * radius;
}

class Circle {
  constructor(radius) {
    this.г = radius;
  }
  area() {
    return Math.PI * this.r * this.r;
  }
  circumference() {
    return 2 * Math.PI * this.r;
  }
}

//import Circle from './geometry/circle.js';

//----------------------------------
//____________Объекты_____________//
//Объект представляет собой неупорядоченную коллекцию свойству каждое из которых имеет имя и значение
//Свойства, которые не были унаследованы, в JavaScript называются собственными свойствами
//к имени и значению каждое свойство имеет три атрибута свойства:
//- writable (допускает запись)
//- enumerable (допускает перечисление)
//- configurable (допускает конфигурирование)

//___Создание объектов
Object.create();

// объектный литерал
let point = {
  x: 0,
  у: 0,
};

//Создание объектов с помощью операции new
//функция называется конструктором
let о = new Object(); // Создает пустой объект: то же, что и {}

//Прототипы
//Объекты, создаваемые с использованием ключевого слова new применяют prototype функции конструктора
//Таким образом, объект, созданный посредством new Object(), наследует Object .prototype , как и объект, созданный с помощью { }
//Большинство встроенных конструкторов имеют прототип, унаследованный от Object.prototype
//Date.prototype наследует свойства от Object.prototype  и  такая связанная последовательность объектов - прототипов называется цепочкой прототипов

//Object.create();
let ol = Object.create({ х: 1, у: 2 }); // о1 наследует свойства х и у.
ol.x + ol.y; // => 3

//___Запрашивание и установка свойст
let author = book.author; //Получить свойство "author” объекта book
let паше = author.surname; //Получить свойство "surname” объекта author
let title = book["main title"]; // Получить свойство "main title"
// объекта book
book.edition = 7; // Создать свойство "edition" объекта book
book["main title"] = "ECMAScript"; // Изменить свойство "main title"

//Объекты как ассоциативные массивы
function addstock(portfolio, stockname, shares) {
  portfolio[stockname] = shares;
}

//Наследование
//наследует свойства от объекта-прототипа
let unitcircle = { r: 1 }; // Объект, от которого будет
// делаться наследование
let с = Object.create(unitcircle); // с наследует свойство г
с.х = 1;
с.у = 1; // с определяет два собственных свойства
с.г = 2; // с переопределяет свое унаследованное свойство
unitcircle.г; // => 1: прототип не затронут

//Ошибки доступа к свойствам
book.subtitle; // => undefined: свойство не существует
//Защититься от возникновения проблемы
let surname = undefined;
if (book) {
  if (book.author) {
    (surname = book), author, surname;
  }
}
// альтернатива
surname = book && book.author && book.author.surname;
let surname = book?.author?.surname;

//Удаление свойств
//Операция delete не удаляет свойства, которые имеют атрибут configurable , установленный в false
delete book.author; // Объект book теперь не имеет свойства author

//Проверка свойств
//in - tru e , если объект имеет собственное или унаследованное свойство с указанным именем
let о = { х: 1 };
"х" in о;
//hasOwnProperty () - имеет ли данный объектсобственное свойство с заданным именем.Для унаследованных свойств он возвращает false:
let о = { х: 1 };
о.hasOwnProperty("х"); // => true
//propertylsEnumerable() - tru e , только если именованное свойство является собственным и атрибут enumerable имеет значение true
let о = { х: 1 };
о.propertylsEnumerable("х"); // => true
//просто запросить свойство и применить !==
let о = { х: 1 };
о.х !== undefined; // => true

//___Перечисление свойств
for (let р in о) {
  if (!o.hasOwnProperty(р)) continue; // Пропускать унаследованные
  // свойства
}

for (let р in о) {
  if (typeof о[р] === "function") continue; // Пропускать все методы
}

//Расширение объектов
let target = { х: 1 },
  source = { у: 2, z: 3 };
for (let key of Object.keys(source)) {
  target[key] = source[key];
}
target; // => {x: 1, y: 2, z: 3}
//Object.assign()
Object.assign({ x: 1 }, { x: 2, y: 2 }, { y: 3, z: 4 }); // => {x: 2, y: 3, z:4}

//Сериализация объектов
//преобразования состояния объекта в строку
let о = { х: 1, у: { z: [false, null, ""] } }; // Определение тестового
// объекта
let s = JSON.stringify(о); //s ==  {"х": 1, "у":{"z": [false,null:""] }}
let p = JSON.parse(s); // p == {x: 1, y: {z : [false, null, ""])}

//____Методы Object

//toString()
let s = { x: 1, у: 1 }.toString(); //"[object Objec]"

//toLocaleString()
point.toString(); // => "(1000, 2000)"
point.toLocaleString(); // => "(1,000, 2,000)": обратите внимание
//на наличие разделителей тысяч

//valueOf()
//применяется для преобразования в числа

// Метод toJSON()
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return "(${this.x}, ${this.y})";
  },
  toJSON: function () {
    return this.toString();
  },
};
JSON.stringifу([point]); //=> ’["d, 2)"]'

//___ Расширенный синтаксис объектных литералов
let х = 1,
  у = 2;
let о = {
  х: х,
  У: У,
};
//опустить значения если совподает с ключом
let о = { х, у };

//Вычисляемые имена свойств
const PROPERTY_NAME = "pi";
function computePropertyName() {
  return "p" + 2;
}
let о = {};
о[PROPERTY__NAME] = 1;
о[computePropertyName()] = 2;

//Символы в качестве имен свойств
//символы хороши для создания уникальных имен свойств
const extension = Symbol("my extension symbol");
let о = {
  [extension]: {
    /* в этом объекте хранятся данные расширения */
  },
};
о[extension].х = 0; // Это не будет конфликтовать
// с остальными свойствами о

//Операция распространения
let position = { х: 0, у: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.у + rect.width + rect.height; // => 175

//Сокращенная запись методов
let square = {
  area: function () {
    return this.side * this.side;
  },
  side: 10,
};
square.area(); // => 100

//Методы получения и установки свойств
//с использованием сокращенной записи
let о = {
  // Обыкновенное свойство с данными
  dataProp: value,
  // Свойство с методами доступа определяется как пара функций
  get accessorProp() {
    return this.dataProp;
  },
  set accessorProp(value) {
    this.dataProp = value;
  },
};

let р = {
  //х и у - обыкновенные свойства с данными, допускающие чтение и запись
  х: 1.0,
  у: 1.0,
  // г - свойство с методами доступа, допускающее чтение и запись,
  // с методами получения и установки.
  //Не забывайте помещать запятую после методов доступа,
  get r() {
    return Math, hypot(this, x, this.y);
  },
  set r(newvalue) {
    let oldvalue = Math.hypot(this.x, this.y);
    let ratio = newvalue / oldvalue;
    this.x *= ratio;
    this.y *= ratio;
  },
  // theta - свойство с методами доступа, допускающее только чтение
  // и имеющее лишь метод получения.
  get theta() {
    return Math.atan2(this.y, this.x);
  },
};
p.r; // => M a t h .SQRT2
p.theta; // => Math.PI / 4

//--------------------------------------
//______________Массивы_______________//
//упорядоченную коллекцию значений
//элемент имеет числовую позицию в массиве
//Индексы в массивах JavaScript начинаются с нуля
//могут быть разреженными: элементы не обязаны иметь смежные индексы, поэтому возможно наличие брешей
//Каждый массив JavaScript имеет свойство length

//___Создание массивов

//Литералы типа массивов
let primes = [2, 3, 5, 7, 11];
let table = [base, base + 1, base + 2, base + 3];
let undefs = [, ,];

//Операция распространения
let а = [1, 2, 3];
let b = [О, ...а, 4]; // b == [0, 1, 2, 3, 4]
let original = [1, 2, 3];
let copy = [...original];
copy[0] = 0; // Модификация копии не приводит к изменению оригинала
original[0]; // => 1
let digits = [..."0123456789ABCDEF"];
digits; // => ["0",”1","2","3",”4","5”,"б",”7",”8”,"9",
// "А","В","С","D","Е", "F"]

//Конструктор Array()
let а = new Array();
let а = new Array(10);
let а = new Array(5, 4, 3, 2, 1, "testing, testing");

//Array.of()
Array.of(); //=>[]; при вызове без аргументов возвращает пустой массив
Array.of(10); // => [10]; при вызове с единственным числовым
// аргументом способна создавать массивы
Array.of(1, 2, 3); // => [1, 2, 3]

//Array.from ()
//работает подобно операции распространения [...iterable]
let сору = Array.from(original);

//____ Чтение и запись элементов массива
let а = ["world"]; // Начать с одноэлементного массива
let value = a[0]; // Прочитать элемент 0
a[1] = 3.14; // Записать элемент 1
a.length; //2

// Разреженные массивы
let а = new Array(5); // Элементы отсутствуют, но a.length равно 5
а = []; // Создает массив без элементов и length = 0
а[1000] = 0; // Присваивание добавляет один элемент,
//но устанавливает length в 1001

//___Длина массива
[].length[("a", "b", "с")].length; // => 0: массив *не содержит элементов // => 3: самый высокий индекс равен 2

//___Добавление и удаление элементов массива
let а = []; // Начать с пустого массива
a.push("zero");
let а = [1, 2, 3];
delete а[2];
2 in а; // => false: индекс 2 в массиве не определен
a.length; // => 3: delete не влияет на длину массива

//___Итерация по массивам
let letters = [..."Hello world"]; // Массив букв
let string = "";
for (let letter of letters) {
  string += letter;
}
string; // => "Hello world"; мы повторно собрали первоначальный текст

let everyother = "";
for (let [index, letter] of letters.entries()) {
  if (index % 2 === 0) everyother += letter; // буквы по четным индексам
}
everyother; // => "Hlowrd"

let uppercase = "";
letters.forEach((letter) => {
  // Обратите внимание на синтаксис
  // стрелочной функции
  uppercase += letter.toUpperCase();
});
uppercase; // => "HELLO WORLD"

let vowels = "";
for (let i = 0; i < letters.length; i++) {
  let letter = letters[i];
  if (/[aeiou]/.test(letter)) {
    vowels += letter;
  }
}
vowels; // => "еоо"

// Сохранить длину массива в локальной переменной
for (let i = 0, len = letters.length; i < len; i++) {
  // тело цикла остается прежним
}

// Итерация в обратном направлении с конца до начала массива
for (let i = letters.length - 1; i >= 0; i--) {
  // тело цикла остается прежним
}

//Многомерные массивы
table[5][7]; // => 35

//___Методы массивов

//forEach()
let data = [1, 2, 3, 4, 53],
  sum = 0;
// Вычислить сумму элементов массива
data,
  forEach((value) => {
    sum += value;
  });

//map()
let a = [1, 2, 3] / a.map((x) => x * x);

//find () И findlndex()
let а = [1, 2, 3, 4, 5];
a.findlndex((х) => х === 3); // => 2; значение 3 находится по индексу 2
a.findlndex((х) => х < 0); // => - 1 ; отрицательных чисел в массиве нет
a.find((х) => х % 5 === 0); // => 5: число, кратное 5
a.find((х) => х % 7 === 0); // => undefined: числа, кратные 7,в массиве отсутствуют

//every() и some()
let а = [1, 2, 3, 4, 5];
a.every((х) => х < 10); // => true: все значения < 10
a.every((x) => х % 2 === 0); // => false: не все значение четные

//reduce() И reduceRight()
let а = [1, 2, 3, 4, 51];
a.reduce((х, у) => х + у, 0) // => 15; сумма значений
  [
    //reduceRight - имеет ассоциативность справа налево

    //Выравнивание массивов с помощью flat() и flatMap()
    (1, [2, 3])
  ].flat(); // => [1, 2, 3]
let а = [1, [2, [3, [4]]]];
a.flat(1); // => [1, 2, [3, [ 4 ] ] ]
a.flat(2); // => [1, 2 , 3, [4]]
a.flat(3); // => [1, 2, 3, 4]
a.flat(4); // => [1, 2, 3, 4]
//вызов a .flatMap ( f ) —то же самое, что и а.шар(f).flat()
let phrases = ["hello world", "the definitive guide"];
let words = phrases.flatMap((phrase) => phrase.split(" "));
words; // => ["hello", "world", "the", "definitive", "guide"];

//concat()
let a = [1, 2, 3];
a.concat(4, 5); // => [1/2,3,4,5]
a.concat([4 / 5] / [6, 7]); // => [1,2,3, 4,5, 6,7]; массивы выравниваются

//push() , pop(), shift() и unshift ()
let stack = []; // stack == []
stack.push(1, 2); // stack == [1, 2];
stack.pop(); // stack == [1]; возвращается 2
//добавления элементов в конец массива и shift()
//unshift() добавляет элемент или элементы в начало массива

//slice(), splice() , fill() и copyWithin()
let а = [1, 2, 3, 4, 5];
a.slice(0, 3); // Возвращается[1, 2, 3]
//модифицирует массив
splice();
let а = [1, 2, 3, 4, 5, 6, 7, 8];
a.splice(4); // => [5,6,7,81; а теперь [1,2,3,4]
let а = new Array(5);
a.fill(0); //=> [0,0,0,0,0]; заполнить массив нулями
a.fill(9, 1); // => [0,9,9,9,9]; заполнить значениями 9 начиная с индекса 1
a.fill(8, 2, -1); // => [0,9,8,8,9]; заполнить значениями 8 по индексам 2, 3
let а = [1, 2, 3, 4, 5];
a.copyWithin(1); // => [1,1,2,3,4]: копировать элементы массива в позиции, начиная с первого
a.copyWithin(2, 3, 5); // => [1, 1, 3, 4, 4] : копировать последние 2 элемента по индексу 2
a.copyWithin(0, -2); // => [4,4,3,4,4] : отрицательные смещения тоже работают

//indexOf() и lastlndexOf()
//возвращают индекс
let а = [0, 1, 2, 1, 0];
a.indexOf(1); // => 1: а [ 1 ] равно 1
a.lastlndexOf(1); // => 3: а [3] равно 1

//includes
let a = [1, true, 3, NaN];
a.includes(true); // => true

//sort()
let а = ["banana", "cherry", "apple"];
a.sort(); // a ~ [ "apple", "banana", "cherry"]
let а = [33, 4, 1111, 222];
a.sort((a, b) => b - а); //а == [1111, 222, 33, 4]; обратный числовой порядок

а.sort(function (s, t) {
  let a = s.toLowerCase();
  let b = t.toLowerCase();
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}); // a == ["ant","Bug","cat","Dog"]; сортировка,
// нечувствительная к регистру

//reverse()
let а = [1, 2, 3];
a.reverse(); // а == [3,2,1]

//join()
let а = [1, 2, 3];
a.join(); // => ”1,2,3”

//isArray
//Статические
Array.isArray([]); // => true
Array.isArray({}); //=> false

//___Объекты, похожие на массивы
let а = {}; // Начать с обыкновенного пустого объекта
// Добавить свойства, чтобы сделать его "похожим на массив"
let i = 0;
while (i < 10) {
  a[i] = i * i;
  i++;
}
a.length = i;
// Выполнить итерацию по нему, как если бы он был настоящим массивом
let total = 0;
for (let j = 0; j < a.length; j++) {
  total += a[j];
}

//document.querySelectorAll() - возвращают объекты, похожие на массивы

let а = { 0: "а", 1: "Ь", 2: "с", length: 3 }; // Объект, похожий на массив
Array.prototype.map.call(a, (x) => x.toUpperCase()); // => ["А","В","C"]

//Строки как массивы
let s = "test";
s.charAt(0); // => "t"
s[l]; // => ”e"

//---------------------------------
//____________Функции____________//

//____Определение функций

//Объявления функций
function factorial(х) {
  if (х <= 1) return 1;
  return х * factorial(х - 1);
}

//Выражения функций
// Обратите внимание, что м ы присваиваем ее переменной,
const square = function (х) {
  return х * х;
};

//Стрелочные функции
const sum = (х, у) => {
  return х + у;
};

//Вложенные функции
//они могут получать доступ к параметрам и переменным функции внутрь которой вложены
function hypotenuse(а, b) {
  function square(х) {
    return х * х;
  }
  return Math.sqrt(square(a) + square(b));
}

//___Вызов функций
//как функции
//как методы
//как конструкторы
//косвенно посредством их методов call() и apply();
//неявно через языковые средства JavaScript

//в строгом режиме контекстом вызова(this) является undefined,в нестрогом режиме глобальный объект

//Вызов функции
printprops({ х: 1 });
let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5);
let probability = factorial(5) / factorial(13);

//_Вызов метода
//Метод — это не более чем функция JavaScript, которая хранится в свойстве объекта
let calculator = {
  // Объектный литерал
  operandl: 1,
  operand2: 1,
  add() {
    // Для этой функции мы используем сокращенный
    // синтаксис методов
    // Обратите внимание на применение ключевого слова this
    // для ссылки на вмещающий объект.
    this.result = this.operandl + this.operand2;
  },
};
calculator.add(); // Вызов метода для вычисления 1+1
calculator.result; // => 2

о["m"](х, у); // Еще один способ записи о.т(х,у)

//Формирование цепочек методов
//Когда методы возвращают объекты, возвращаемое значение одного вызова метода можно применять как часть дальнейшего вызова.
//Последовательно запустить три асинхронных операции, обрабатывая ошибки
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);

let o = {
  m: function () {
    //Метод m объекта
    let self = this; //Сохранить значение this в переменной
    this === 0; //true: this является объектом о
    f(); //Теперь вызвать вспомогательную функцию f (
    function f() {
      //Вложенная функция f
      this === 0; //=> false: this является глобальным объектом или undefined
      self === 0; //=> true: self является внешним значением this
    }
  },
};
o.m(); //Вызвать метод m на объект

//способ обхода проблемы c передачей this
const f = () => {
  this === о // true, поскольку стрелочные функции наследуют this
}

//Другой обходной путь
const f = (function () {
  this === о //true, поскольку мы привязали эту функцию к внешнему this
}).bind(this);

//_Вызов конструктора
//стр 221
