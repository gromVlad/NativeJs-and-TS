console.log("Hello World!");

//------------------------------------
//______Лексическая структура______//

//____Текст программы JavaScript
//язык, чувствительный к регистру символов

//____Комментарии
// Это однострочный комментарий
/*
 * Это многострочный комментарий. Добавочные символы * в начале каждой
 * строки не являются обязательной частью синтаксиса;
 * просто они классно выглядят!
 */

//____Литералы
//значение данных, находящееся прямо в программе
12; // Число двенадцать
1.2; // Число одна целая и две десятых
("hello world"); // Строка текста
("Hi"); // Еще одна строка
true; // Булевское значение
false; // Другое булевское значение
null; // Отсутствие объекта

//____Идентификаторы и зарезервированные слова
//это просто имя ,для именования констант, переменных, свойств, функций и классов.

//____Зарезервированные слова
//вроде if , while и for...

//____Unicode
//математические символы и слова
const n = 3.14;
const si = true;

//___Необязательные точки с запятой
//всегда можете опускать точку с запятой между двумя операторами, если они записаны в отдельных строках
а = 3;
b = 4;
а = 3;
b = 4;

//Защитная ; сохраняет этото ператор отдельным
[х, х + 1, х + 2].forEach(console.log);

//разрыв строки
//return , throw, yield , break и continue

//------------------------------------
//___Типы, значения и переменные____//
//элементарные типы и объектные типы
//Объектные типы JavaScript являются изменяемыми, элементарные типы — неизменяемыми.
//Константы объявляются с помощью co n st, а переменные посредством let(или var в более старом коде JavaScript).

//___Числа
//Number
О;
3;
10000000;

//шестнадцатеричных целочисленных литералов
Oxff; // => 255: (15*16 + 15)
OxBADCAFE; // => 195939070

//целые числа можно также выражать в двоичном (с основанием 2) или восьмеричном (с основанием 8) виде с применением префиксов 0Ь и Оо(или 0В и 00) вместо Ох
0b0101; // => 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
0o377; // => 255: (3*64 + 7*8 + 7*1)

3.14;
2345.6789;
0.333333333333333333;
6.02e23; // 6.02 х 1023
1.4738223e-32; // 1.4738223 х 10'32

//числовых литералах можно применять подчеркивания, чтобы разбивать их на порции
let billion = 1_000_000_000; // Подчеркивание как разделитель тысяч,
let bytes = 0x89_ab_cd_ef; // Подчеркивание как разделитель байтов,
let bits = 0b0001_1101_0111; //Подчеркивание как разделитель полубайтов,
let fraction = 0.123_456_789; // Работает и в дробной части.

//____ Арифметические действия
Math.pow(2, 53); // => 9007199254740992: 2 в степени 53
Math.round(0.6); // => 1.0: округляет до ближайшего целого
Math.ceil(0.6); // => 1.0: округляет в большую сторону до целого
Math.floor(0.6); // => 0.0: округляет в меньшую сторону до целого
Math.abs(-5); // => 5: абсолютная величина
Math.max(x, y, z); // Возвращает наибольший аргумент
Math.min(x, y, z); // Возвращает наименьший аргумент
Math.random(); // Псевдослучайное число х, где 0 <= х < 1.0
Math.PI; // п: длина окружности, деленная на диаметр
Math.E; // е: основание натурального логарифма
Math.sqrt(3); // => 3**0.5: квадратный корень из 3
Math.pow(3, 1 / 3); // => 3** (1/3) : кубический корень из 3
Math.sin(0); // Тригонометрия: также есть Math.cos, Math.atan и т.д.
Math.log(10); // Натуральный логарифм 10
Math.log(100); // Math.LN10 // Десятичный логарифм 100
Math.log(512); // Math.LN2 // Двоичный логарифм 512
Math.exp(3); // Math.E в кубе
//...

//не генерируют ошибки  а возврощает Infinity
1 / 0 - // => Infinity
  1 / 0; // => -Infinity
0 / 0; // => NaN

Number.parselnt(); // То же, что и глобальная функция parselnt
Number.parseFlot();
Number.isNaN(x); // Является ли х значением NaN?
Number.isFinite(x); // Является ли х конечным числом?
Number.islnteger(x); // Является ли х целым числом?
Number.isSafelnteger(х); // Является ли х целым числом -(2**53) < х < 2**

//число не может быть представлено точно
let х = 0.3 - 0.2; // тридцать центов минус двадцать центов
let у = 0.2 - 0.1; // двадцать центов минус десять центов
х === 0.1; // => false: .3-.2 не равно Л

//___Bigint
1234n;
Bigint(Number.MAX_SAFE_INTEGER); // => 9007199254740991n

//Арифметические действия -подобно арифметическим действиям но при деление отбрасывает любой остаток и округляет в меньшую сторону
//смешивать операнды типа Bigintс обычными числовыми операндами нельзя.
//Напротив, операции сравнения работают со смешанными числовыми типами
1000n + 2000n; //=> ЗОООп
1 < 2n; // => true

//___ Дата и время
let timestamp = Date.nowO; //Текущее время как отметка времени (число) .
let now = new Date(); // Текущее время как объект Date.
let ms = now.getTime(); // Преобразовать в миллисекундную отметку времени.
let iso = now.toISOString(); // Преобразовать в строку со стандартным форматом.

//___Текст
// строки являются итерируемымые
// "" '' ``
(""); // Пустая строка: содержит ноль символов
("testing");
("3.14");
('name="myform" ');
("Wouldn’t you prefer 0*Reilly's book?");
"n is the ratio of a circle's circumference to its radius"`"She said 'hi'", he said.`;

// Строка, представляющая две строки, которые записаны в одной строке:
("two\nlines ");

// Однострочная строка, записанная в трех строках:
"опе\
long\
line" // Двухстрочная строка, записанная в двух строках:
`the newline character at the end of this line
is included literally in this string`;

//<button onclick="alert ('Thank you') ">Click Me</button>

//экранирование
("YouVre right, it can*t be a quote");

//\u{1f600} — эмотикон ухмыляющаяся рожица

//конкатенации строк
let msg = "Hello, " + "world"; // Образует строку "Hello, world"

//Строки можно сравнивать с помощью стандартных операций равенств

let s = "Hello, world"; // Начать с некоторого текста.
s.length;
s.substring(l, 4); // => "ell": 2 - й, 3 - й и 4 - й символы
s.slice(1, 4); // => "ell": то же самое
s.slice(-3); // => "rid": последние 3 символа
s.split(", "); // => ["Hello", "world"]: разбивает по строке разделителя
s.indexOf("1"); // => 2: позиция первой буквы
s.lastlndexOf("1"); // => 10: позиция последней буквы 1
s.startsWith("Hell"); // => true: строка начинается с этого
s.endsWith("!"); // => false: s не оканчивается этим
s.includes("or"); // => true: s включает подстроку "or"
s.replace("Но", "уа"); // => "Heya, world"
s.toLowerCase(); // => "hello, world"
s.toUpperCase(); // => "HELLO, WORLD"
s.charAt(0); // => "Н": первый символ
s.charAt(s.length - 1); // => "d": последний символ
"х".padStart(3); // => " х": добавляет пробелы слева до длины 3
"test".trim(); // => "test” : удаляет пробелы в начале и конце
s.concat("!"); // => "Hello, world!” : взамен просто используйте операцию +
"о".repeat(5); // => "<><><><><>” : выполняет конкатенацию

//Не забывайте, что строки в JavaScript неизменяемы,возвращают новые строки: они не модифицируют строку

let s = "hello, world";
s[0]; // => "h”
s[s.length - 1]; // => "d"

//Шаблонные литералы
let name = "Bill";
let greeting = `Hello ${name}.`; // greeting == "Hello Bill

//____регулярные выражение
let text = "testing: 1, 2, 3";
let pattern = /\d+/g;
pattern.test(text); // => true: есть совпадение

//___Булевские значения
//true и false

// false
//undefined null 0 -0 NaN ""// пустая строка

//Все остальные значения true

//Операция && выполняет булевскую операцию "И"
//Операция | | — это булевская операция “ИЛИ”
//! выполняет булевскую операцию НЕ
if ((х === 0 && у === 0) || !(z === 0)) {
  // х и у равны нулю или z не равно нулю
}

//___null и undefined
//null - отсутствие значения
//undefine - не были инициализированы, и то, что получается при запрашивании значений свойств объекта или элементов массива, которые не существуют

//__Тип Symbol
//Чтобы получить значение символа, понадобится вызвать функцию Symbol (), которая никогда не возвращает то же самое значение дважды, даже когда вызывается с таким же аргументом.
let strname = "string name";
let symname = Symbol("propname");
let о = {};
о[strname] = 1;
о[strname]; // => 1: доступ к свойству со строковым именем

toString(); //— единственный интересный метод в экземплярах Symbol
let s = Symbol("sym_x");
s.toString(); // => "Symbol(sym_x) "

//Symbol.for() всегда возвращает то же самое значение
let s = Symbol.for("shared");
let t = Symbol.for("shared");
s === t; // => true
s.toString(); // => "Symbol (shared) "
Symbol.keyFor(t); // => "shared"

//__ Глобальный объект
//его свойствами являются глобально определенные идентификаторы, доступные программе JavaScript
//Node - global
//Window
//ссылки на глобальный объект - globalThis

//___Неизменяемые элементарные значения и изменяемые объектные ссылки
//Элементарные значения неизменяемый
//Объекты отличаются от элементарных значений. Прежде всего, они изменяемы — их значения можно модифицировать
let о = { х: 1 };
о.х = 2;
о.у - 3;
let а = [1, 2, 3];
а[0] = 0;
а[3] = 4;

let о = { х: 1 },
  р = { х: 1 }; // Два объекта с одинаковыми свойствами
о === р; // => false: отдельные объекты никогда не равны

// объекты называют ссылочными типами они ссылаются на тот же самый внутренний объект
let а = []; // Переменная а ссылается на пустой массив
let b = а; // Теперь на тот же самый массив ссылается переменная b
b[0] = 1; // Изменить массив, на который ссылается переменная b
а[0]; // => 1: изменение также будет видимым через переменную а
а === b; // => true: а и b ссылаются на тот же самый объект,поэтому они равны

//Если вы хотите создать новую копию объекта или массива, тогда должны явно скопировать свойства объекта или элементы массива
let a = ["а", "b", "с"]; // Массив, который мы хотим скопировать
let b = []; // Отдельный массив, куда м ы будем копировать
for (let i = 0; i < a.length; i++) {
  // Для каждого из всех индексов
  b[i] = a[i]; // Копировать элемент а в b
}

let с = Array.from(b); //В ES6 копируйте массивы с помощью Array.from()

function equalArrays(а, b) {
  if (а === b) return true; // Идентичные массивы равны
  if (a.length !== b.length) return false; //Массивы разного размера
  //не равны
  for (let i = 0; i < a.length; i++) {
    //Цикл по всем элементам
    if (a[i] !== b[i]) return false; //Если любые элементы отличаются,
    //то массивы не равны
  }
  return true; // Иначе они равны
}

//___Преобразования типов
"7" + "4"; //11
10 + " objects"; // => ”10 objects": число 10 преобразуется в строку

//___Преобразования и равенство
null == undefined; //=> true: эти два значения трактуются как равные,
"0" == 0; //=> true перед сравнением строка преобразуется в число.

//___Явные преобразование
Number("3"); // => 3
String(false); // => "false"
Boolean([]); // => true

let n = 17;
let binary = "Ob" + n.toString(2); // binary == "OblOOOl

let n = 123456.789;
n.toFixed(0); // => "123457"

//___неявное преобразование
х +
  "" + // => String(х)
  х; // => Number (х)
х - 0; // => Number (х)
!!х; // => Boolean(х) : обратите внимание на два символа !

parselnt("-12.34"); // => -12
parseFloat(" .1")(
  // = > 0.1

  //___ Преобразования объектов в элементарные значения
  //prefer-string toString() /  prefer-number valueOf() /  no-preference
  { х: 1, у: 2 }
).toString(); // => "[object Object]”
let d = new Date(2010, 0, 1); //1 января 2010 года (тихоокеанское время)
d.valueOf(); // => 126233280

//___Объявление и присваивание переменных
// let / const
//const только для значений, которые не должны изменяться
let i = 0,
  j = 0,
  k = 0;

//Переменные и константы, объявленные с помощью let и const, имеют блочную область видимости(if / else /while / for)
const х = 1; //О бъявить х как глобальную константу
if (х === 1) {
  let х = 2; //В н утр и блока х может ссылаться на другое значение
  console.log(х); // Выводится 2
}
console.log(х); //В ы водится 1: мы снова вернулись  в глобальную область видимости
let х = 3; //ОШИБКА! Синтаксическая ошибка при попытке
//п о в т о р н о го объявления х

//var
//функциональная видимость

//___Деструктурирующее присваивание
let [х, у] = [1, 2]; // То же, что и l e t х = 1, у = 2
[X, у] = [х + 1, у + 1]; // То же, что и х = х + 1, у = у + 1

let о = { х: 1, у: 2 }; // Объект, по которому будет
// делаться проход в цикле
for (const [nаше, value] of Object.entries(о)) {
  console.log(nаше, value);
}

let [х, у] = [1]; // х == 1; у == u n d efin ed
[х, у] = [1, 2, 3]; // х == 1; у == 2

let [х, ...у] = [1, 2, 3, 4]; // у == [2, 3, 4]

let [а, [Ь, с]] = [1, [2, 2.5], 3]; // а == 1; b == 2; с ==

let [first, ...rest] = " Hello ";

let transparent = { г: 0.0, g: 0.0, b: 0.0, а: 1.0 }; // Цвет RGBA
let { г, g, b } = transparent; // г = 0 .0; g == 0 .0; b == 0 .0

const sin = Math.sin,
  cos = Math.cos,
  tan = Math.tan;
const { sin, cos, tan } = Math;

const { cos: cosine, tan: tangent } = Math;

let points = [
  { х: 1, у: 2 },
  { х: 3, у: 4 },
];
let [{ х: x1, у: у1 }, { х: х2, у: у2 }] = points;

//----------------------------------------
//_________Выражения и операции________//
//синтаксическая конструкция JavaScript

//___Первичные выражения
//константы или литеральные значения,ссылку на переменную, this
("hello"); // Строковый литерал
true; // Вычисляется как булевское истинное значение

//___Инициализаторы объектов и массивов
//созданные объекты или массивы, разделяемый запятыми список выражений
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

//___Выражения определений функций
//защититься от ошибок

//“литералом функции"
let square = function (х) {
  return х * х;
};

//___Выражения доступа к свойствам
//[],.

//___Условный доступ к свойствам
let а = { b: null };
a.b?.c?.d; // => undefined

//___Выражения вызова
a.sort();
Math.max(x, y, z);
f(0);

//___Условный вызов
о?.m(); // Условный доступ к свойству, обыкновенный вызов

//___Выражения создания объектов
new Object();

//___Обзор операций
//большинство  + и =
//некоторые delete и instanceof
//ассоциативность операций — слева направо или справа налево

//___Количество операндов
// бинарными операциямиу которые объединяет два выражения * / ...
//унарных операций ++
//тернарная операция _ ? _ : _

//___Побочные эффекты операций
//операции присваивания , ++_, _++ , delete

//___Приоритеты операций
//Интерпретатор JavaScript всегда вычисляет выражения строго в порядке слева направо

//___Арифметические выражения
//Базовыми арифметическими операциями являются ** (возведение в степень), * (умножение), / (деление), % (модуль: остаток от деления), + (сложение) и - (вычитание)

//___Операция +
1 + 2; // => 3
"hello" + " " + "there"; // => "hello there"
"1" + "2"; // => "12"

//___Унарные арифметические операции
//модифицируют значение единственного операнда

//___Побитовые операции
//низкоуровневые манипуляции битами в двоичном представлении чисел
// & | ~ << >>

//___Операции равенства и неравенства
//== и == !==..

//___Операции сравнения
// <= => > <

//___Операция in
//tr u e , если значением с левой стороны будет имя свойства объекта с правой стороны
let point = { х: 1, у: 1 };
"х" in point; //=> true

//___Операция instanceof
//экземпляром класса
let d = new Dated(); //Создание нового объекта с помощью конструктора Dated
d instanceof Date; // => true

//___Логические выражения
// &&, | | и !
х === 0 && у === 0; // true, если и только если х и у равны 0
let max = maxWidth || preferences.maxWidth || 500;
!х; //х ложное равно true

//___Выражения присваивания
i = j = k = 0; // Инициализация трех переменных значением

//___Присваивание с действием
total += salesTax;

//___Вычисление выражений
eval("3+2"); // => 5

//___Смешанные операции
х > 0 ? х : -х; // Абсолютное значение х

//если левый операнд не является n u ll или undefined
let options = {
  timeout: 0,
  title: "",
  verbose: false,
  n: null,
};
options.timeout ?? 1000; // => 0: как определено в объекте

//Операция typeof
typeof value === "string";

//Операция delete
let о = { х: 1, у: 2 };
delete о.х;

//Операция await
//асинхронное программирование

//Операция void
//отбрасывает значение и возвращает undefined.
let counter = 0;
const increment = () => void counter++;
increment(); // => undefined

//Операция "запятая"
(i = 0), (j = l), (k = 2);

//--------------------------------------
//_____________Операторы______________//

//___Операторы-выражения
counter++;
console.log();
Math.cos();

//___Составные и пустые операторы
{
  //...
}

//___if
if (n === 1) {
  // Выполнить блок кода #1
} else if (n === 2) {
  // Выполнить блок кода #2
} else if (n === 3) {
  // Выполнить блок кода #3
} else {
  // Если ни одна из конструкций else не выполнилась, тогда выполнить блок кода #4
}

//___switch
switch (key) {
  case value:
    break;

  default:
    break;
}

//___ Циклы

//while
let count = 0;
while (count < 10) {
  console.log(count);
  count++;
}

//do/while
//тело цикла всегда выполняется, по крайней мере, один раз
do {
  console.log(a[i]);
} while (++i < len);

//for
for (let index = 0; index < array.length; index++) {
  const element = array[index];
}

//for / of
//работает с итерируемыми объектами
let data = [1, 2, 3, 4, 5, 6, 7, 8, 9],
  sum = 0;
for (let element of data) {
  sum += element;
}
sum; // => 45

//for / of с объектами
let о = { х: 1, у: 2, z: 3 };
let keys = "";
for (let k of Object.keys(o)) {
  keys += k;
}
keys; // => "xyz"

let sum = 0;
for (let v of Object.values(о)) {
  sum += v;
}
sum; // => 6

let pairs = "";
for (let [k, v] of Object.entries(o)) {
  pairs += k + v;
}
pairs; // => "xly2z3"

//for / of со строками
let frequency = {};
for (let letter of "mississippi") {
  if (frequency[letter]) {
    frequency[letter]++;
  } else {
    frequency[letter] = 1;
  }
}
frequency; // => {m: 1, i: 4, s: 4, p: 2}

//for/of с классами Set и Мар
let text = "Na па па па па па па па Batman!";
let wordSet = new Set(text.split(" "));
let unique = [];
for (let word of wordSet) {
  unique.push(word);
}
unique; // => ["Na", "na", "Batman!"]

let m = new Map([[1, "one"]]);
for (let [key, value] of m) {
  key; // => 1
  value; // => "one"
}

//Асинхронная итерация с помощью for/await
async function printStream(stream) {
  for await (let chunk of stream) {
    console.log(chunk);
  }
}

//for/in
//работает с любым объектом
for (let р in о) {
  // Присвоить имена свойств объекта о переменной р
  console.log(о[р]); // Вывести значение каждого свойства
}

let о = { х: 1, у: 2, z: 3 };
let а = [],
  i = 0;
for (a[i++] in о /* пустое тело */);

//___Переходы
// break , continue, return, yield, throw, try/catch/finally

mainloop: while (token !== null) {
  // Код опущен...
  continue mainloop; //Перейти к следующей итерации именованного цикла
  // Код опущен__
}

function square(х) {
  return х * х;
} // Функция, которая имеет
// оператор return
square(2); // => 4

//yield во многом похож на return
// Генераторная функция, которая выдает диапазон целых чисел
function* range(from, to) {
  for (let i = from; i <= to; i++) {
    yield i;
  }
}

//throw
//Генерация исключения

//try / catch / finally:
try {
  // В нормальной ситуации этот код выполняется от начала до конца блока
  // безо всяких проблем. Но иногда он может генерировать исключение,
  // либо напрямую с помощью оператора throw, либо косвенно за счет вызова
  // метода, который генерирует исключение.
} catch (е) {
  // Операторы в данном блоке выполняются, если и только если в блоке try
  // было сгенерировано исключение. Эти операторы могут использовать
  // локальную переменную е для ссылки на объект Error или другое значение,
  // которое было указано в throw. В блоке можно каким-то образом
  // обработать исключение, проигнорировать его, ничего не делая,
  // или повторно сгенерировать исключение с помощью throw.
} finally {
  // Данный блок содержит операторы, которые всегда выполняются
  // независимо от того, что произошло в блоке try.
  // Они выполняются при завершении блока try:
  // 1) нормальным образом после того, как достигнут конец блока;
  // 2) из-за оператора break, continue или return;
  // 3) из-за исключения, которое было обработано конструкцией catch выше;
  // 4) из-за необработанного исключения, которое продолжило
  // свое распространение.
}

//___Смешанные операторы
//with , debugger и "use strict"

//with применяется для облегчения работы с глубоко вложенными иерархиями объектов
document.forms[0].address.value;
//обычно
let f = document.forms[0];
f.name, (value = "");
f.address.value = "";
f.email, (value = "");
//c with
with ((document, forms[0])) {
  // Далее появляется возможность прямого доступа к элементам формы,
  // например:
  name.value = "";
  address.value = "";
  email.value = "";
}

//debugger
function f(о) {
  if (о === undefined) debugger; //Временная строка для отладочных целей
  //Далее идет остальной код функции
}

//"use strict"
//В строгом режиме оператор w ith не разрешен
//В строгом режиме все переменные должны быть объявлены
//функции -> this = равное undefined
//не поддерживающим запись свойствам -> ТуреЕггог
//объект arguments ->  статическую копию значений
//генерации ошибки ТуреЕггог

//___Объявления
//const, let , var, function , class , import и export
const TAU = 2 * Math.PI;
let radius = 3;
var circumference = TAU * radius;

function area(radius) {
  return Math.PI * radius * radius;
}

class Circle {
  constructor(radius) {
    this.г = radius;
  }
  area() {
    return Math.PI * this.r * this.r;
  }
  circumference() {
    return 2 * Math.PI * this.r;
  }
}

//import Circle from './geometry/circle.js';

//----------------------------------
//____________Объекты_____________//
//Объект представляет собой неупорядоченную коллекцию свойству каждое из которых имеет имя и значение
//Свойства, которые не были унаследованы, в JavaScript называются собственными свойствами
//к имени и значению каждое свойство имеет три атрибута свойства:
//- writable (допускает запись)
//- enumerable (допускает перечисление)
//- configurable (допускает конфигурирование)

//___Создание объектов
Object.create();

// объектный литерал
let point = {
  x: 0,
  у: 0,
};

//Создание объектов с помощью операции new
//функция называется конструктором
let о = new Object(); // Создает пустой объект: то же, что и {}

//Прототипы
//Объекты, создаваемые с использованием ключевого слова new применяют prototype функции конструктора
//Таким образом, объект, созданный посредством new Object(), наследует Object .prototype , как и объект, созданный с помощью { }
//Большинство встроенных конструкторов имеют прототип, унаследованный от Object.prototype
//Date.prototype наследует свойства от Object.prototype  и  такая связанная последовательность объектов - прототипов называется цепочкой прототипов

//Object.create();
let ol = Object.create({ х: 1, у: 2 }); // о1 наследует свойства х и у.
ol.x + ol.y; // => 3

//___Запрашивание и установка свойст
let author = book.author; //Получить свойство "author” объекта book
let паше = author.surname; //Получить свойство "surname” объекта author
let title = book["main title"]; // Получить свойство "main title"
// объекта book
book.edition = 7; // Создать свойство "edition" объекта book
book["main title"] = "ECMAScript"; // Изменить свойство "main title"

//Объекты как ассоциативные массивы
function addstock(portfolio, stockname, shares) {
  portfolio[stockname] = shares;
}

//Наследование
//наследует свойства от объекта-прототипа
let unitcircle = { r: 1 }; // Объект, от которого будет
// делаться наследование
let с = Object.create(unitcircle); // с наследует свойство г
с.х = 1;
с.у = 1; // с определяет два собственных свойства
с.г = 2; // с переопределяет свое унаследованное свойство
unitcircle.г; // => 1: прототип не затронут

//Ошибки доступа к свойствам
book.subtitle; // => undefined: свойство не существует
//Защититься от возникновения проблемы
let surname = undefined;
if (book) {
  if (book.author) {
    (surname = book), author, surname;
  }
}
// альтернатива
surname = book && book.author && book.author.surname;
let surname = book?.author?.surname;

//Удаление свойств
//Операция delete не удаляет свойства, которые имеют атрибут configurable , установленный в false
delete book.author; // Объект book теперь не имеет свойства author

//Проверка свойств
//in - tru e , если объект имеет собственное или унаследованное свойство с указанным именем
let о = { х: 1 };
"х" in о;
//hasOwnProperty () - имеет ли данный объектсобственное свойство с заданным именем.Для унаследованных свойств он возвращает false:
let о = { х: 1 };
о.hasOwnProperty("х"); // => true
//propertylsEnumerable() - tru e , только если именованное свойство является собственным и атрибут enumerable имеет значение true
let о = { х: 1 };
о.propertylsEnumerable("х"); // => true
//просто запросить свойство и применить !==
let о = { х: 1 };
о.х !== undefined; // => true

//___Перечисление свойств
for (let р in о) {
  if (!o.hasOwnProperty(р)) continue; // Пропускать унаследованные
  // свойства
}

for (let р in о) {
  if (typeof о[р] === "function") continue; // Пропускать все методы
}

//Расширение объектов
let target = { х: 1 },
  source = { у: 2, z: 3 };
for (let key of Object.keys(source)) {
  target[key] = source[key];
}
target; // => {x: 1, y: 2, z: 3}
//Object.assign()
Object.assign({ x: 1 }, { x: 2, y: 2 }, { y: 3, z: 4 }); // => {x: 2, y: 3, z:4}

//Сериализация объектов
//преобразования состояния объекта в строку
let о = { х: 1, у: { z: [false, null, ""] } }; // Определение тестового
// объекта
let s = JSON.stringify(о); //s ==  {"х": 1, "у":{"z": [false,null:""] }}
let p = JSON.parse(s); // p == {x: 1, y: {z : [false, null, ""])}

//____Методы Object

//toString()
let s = { x: 1, у: 1 }.toString(); //"[object Objec]"

//toLocaleString()
point.toString(); // => "(1000, 2000)"
point.toLocaleString(); // => "(1,000, 2,000)": обратите внимание
//на наличие разделителей тысяч

//valueOf()
//применяется для преобразования в числа

// Метод toJSON()
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return "(${this.x}, ${this.y})";
  },
  toJSON: function () {
    return this.toString();
  },
};
JSON.stringifу([point]); //=> ’["d, 2)"]'

//___ Расширенный синтаксис объектных литералов
let х = 1,
  у = 2;
let о = {
  х: х,
  У: У,
};
//опустить значения если совподает с ключом
let о = { х, у };

//Вычисляемые имена свойств
const PROPERTY_NAME = "pi";
function computePropertyName() {
  return "p" + 2;
}
let о = {};
о[PROPERTY__NAME] = 1;
о[computePropertyName()] = 2;

//Символы в качестве имен свойств
//символы хороши для создания уникальных имен свойств
const extension = Symbol("my extension symbol");
let о = {
  [extension]: {
    /* в этом объекте хранятся данные расширения */
  },
};
о[extension].х = 0; // Это не будет конфликтовать
// с остальными свойствами о

//Операция распространения
let position = { х: 0, у: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.у + rect.width + rect.height; // => 175

//Сокращенная запись методов
let square = {
  area: function () {
    return this.side * this.side;
  },
  side: 10,
};
square.area(); // => 100

//Методы получения и установки свойств
//с использованием сокращенной записи
let о = {
  // Обыкновенное свойство с данными
  dataProp: value,
  // Свойство с методами доступа определяется как пара функций
  get accessorProp() {
    return this.dataProp;
  },
  set accessorProp(value) {
    this.dataProp = value;
  },
};

let р = {
  //х и у - обыкновенные свойства с данными, допускающие чтение и запись
  х: 1.0,
  у: 1.0,
  // г - свойство с методами доступа, допускающее чтение и запись,
  // с методами получения и установки.
  //Не забывайте помещать запятую после методов доступа,
  get r() {
    return Math, hypot(this, x, this.y);
  },
  set r(newvalue) {
    let oldvalue = Math.hypot(this.x, this.y);
    let ratio = newvalue / oldvalue;
    this.x *= ratio;
    this.y *= ratio;
  },
  // theta - свойство с методами доступа, допускающее только чтение
  // и имеющее лишь метод получения.
  get theta() {
    return Math.atan2(this.y, this.x);
  },
};
p.r; // => M a t h .SQRT2
p.theta; // => Math.PI / 4

//--------------------------------------
//______________Массивы_______________//
//упорядоченную коллекцию значений
//элемент имеет числовую позицию в массиве
//Индексы в массивах JavaScript начинаются с нуля
//могут быть разреженными: элементы не обязаны иметь смежные индексы, поэтому возможно наличие брешей
//Каждый массив JavaScript имеет свойство length

//___Создание массивов

//Литералы типа массивов
let primes = [2, 3, 5, 7, 11];
let table = [base, base + 1, base + 2, base + 3];
let undefs = [, ,];

//Операция распространения
let а = [1, 2, 3];
let b = [О, ...а, 4]; // b == [0, 1, 2, 3, 4]
let original = [1, 2, 3];
let copy = [...original];
copy[0] = 0; // Модификация копии не приводит к изменению оригинала
original[0]; // => 1
let digits = [..."0123456789ABCDEF"];
digits; // => ["0",”1","2","3",”4","5”,"б",”7",”8”,"9",
// "А","В","С","D","Е", "F"]

//Конструктор Array()
let а = new Array();
let а = new Array(10);
let а = new Array(5, 4, 3, 2, 1, "testing, testing");

//Array.of()
Array.of(); //=>[]; при вызове без аргументов возвращает пустой массив
Array.of(10); // => [10]; при вызове с единственным числовым
// аргументом способна создавать массивы
Array.of(1, 2, 3); // => [1, 2, 3]

//Array.from ()
//работает подобно операции распространения [...iterable]
let сору = Array.from(original);

//____ Чтение и запись элементов массива
let а = ["world"]; // Начать с одноэлементного массива
let value = a[0]; // Прочитать элемент 0
a[1] = 3.14; // Записать элемент 1
a.length; //2

// Разреженные массивы
let а = new Array(5); // Элементы отсутствуют, но a.length равно 5
а = []; // Создает массив без элементов и length = 0
а[1000] = 0; // Присваивание добавляет один элемент,
//но устанавливает length в 1001

//___Длина массива
[].length[("a", "b", "с")].length; // => 0: массив *не содержит элементов // => 3: самый высокий индекс равен 2

//___Добавление и удаление элементов массива
let а = []; // Начать с пустого массива
a.push("zero");
let а = [1, 2, 3];
delete а[2];
2 in а; // => false: индекс 2 в массиве не определен
a.length; // => 3: delete не влияет на длину массива

//___Итерация по массивам
let letters = [..."Hello world"]; // Массив букв
let string = "";
for (let letter of letters) {
  string += letter;
}
string; // => "Hello world"; мы повторно собрали первоначальный текст

let everyother = "";
for (let [index, letter] of letters.entries()) {
  if (index % 2 === 0) everyother += letter; // буквы по четным индексам
}
everyother; // => "Hlowrd"

let uppercase = "";
letters.forEach((letter) => {
  // Обратите внимание на синтаксис
  // стрелочной функции
  uppercase += letter.toUpperCase();
});
uppercase; // => "HELLO WORLD"

let vowels = "";
for (let i = 0; i < letters.length; i++) {
  let letter = letters[i];
  if (/[aeiou]/.test(letter)) {
    vowels += letter;
  }
}
vowels; // => "еоо"

// Сохранить длину массива в локальной переменной
for (let i = 0, len = letters.length; i < len; i++) {
  // тело цикла остается прежним
}

// Итерация в обратном направлении с конца до начала массива
for (let i = letters.length - 1; i >= 0; i--) {
  // тело цикла остается прежним
}

//Многомерные массивы
table[5][7]; // => 35

//___Методы массивов

//forEach()
let data = [1, 2, 3, 4, 53],
  sum = 0;
// Вычислить сумму элементов массива
data,
  forEach((value) => {
    sum += value;
  });

//map()
let a = [1, 2, 3] / a.map((x) => x * x);

//find () И findlndex()
let а = [1, 2, 3, 4, 5];
a.findlndex((х) => х === 3); // => 2; значение 3 находится по индексу 2
a.findlndex((х) => х < 0); // => - 1 ; отрицательных чисел в массиве нет
a.find((х) => х % 5 === 0); // => 5: число, кратное 5
a.find((х) => х % 7 === 0); // => undefined: числа, кратные 7,в массиве отсутствуют

//every() и some()
let а = [1, 2, 3, 4, 5];
a.every((х) => х < 10); // => true: все значения < 10
a.every((x) => х % 2 === 0); // => false: не все значение четные

//reduce() И reduceRight()
let а = [1, 2, 3, 4, 51];
a.reduce((х, у) => х + у, 0) // => 15; сумма значений
  [
    //reduceRight - имеет ассоциативность справа налево

    //Выравнивание массивов с помощью flat() и flatMap()
    (1, [2, 3])
  ].flat(); // => [1, 2, 3]
let а = [1, [2, [3, [4]]]];
a.flat(1); // => [1, 2, [3, [ 4 ] ] ]
a.flat(2); // => [1, 2 , 3, [4]]
a.flat(3); // => [1, 2, 3, 4]
a.flat(4); // => [1, 2, 3, 4]
//вызов a .flatMap ( f ) —то же самое, что и а.шар(f).flat()
let phrases = ["hello world", "the definitive guide"];
let words = phrases.flatMap((phrase) => phrase.split(" "));
words; // => ["hello", "world", "the", "definitive", "guide"];

//concat()
let a = [1, 2, 3];
a.concat(4, 5); // => [1/2,3,4,5]
a.concat([4 / 5] / [6, 7]); // => [1,2,3, 4,5, 6,7]; массивы выравниваются

//push() , pop(), shift() и unshift ()
let stack = []; // stack == []
stack.push(1, 2); // stack == [1, 2];
stack.pop(); // stack == [1]; возвращается 2
//добавления элементов в конец массива и shift()
//unshift() добавляет элемент или элементы в начало массива

//slice(), splice() , fill() и copyWithin()
let а = [1, 2, 3, 4, 5];
a.slice(0, 3); // Возвращается[1, 2, 3]
//модифицирует массив
splice();
let а = [1, 2, 3, 4, 5, 6, 7, 8];
a.splice(4); // => [5,6,7,81; а теперь [1,2,3,4]
let а = new Array(5);
a.fill(0); //=> [0,0,0,0,0]; заполнить массив нулями
a.fill(9, 1); // => [0,9,9,9,9]; заполнить значениями 9 начиная с индекса 1
a.fill(8, 2, -1); // => [0,9,8,8,9]; заполнить значениями 8 по индексам 2, 3
let а = [1, 2, 3, 4, 5];
a.copyWithin(1); // => [1,1,2,3,4]: копировать элементы массива в позиции, начиная с первого
a.copyWithin(2, 3, 5); // => [1, 1, 3, 4, 4] : копировать последние 2 элемента по индексу 2
a.copyWithin(0, -2); // => [4,4,3,4,4] : отрицательные смещения тоже работают

//indexOf() и lastlndexOf()
//возвращают индекс
let а = [0, 1, 2, 1, 0];
a.indexOf(1); // => 1: а [ 1 ] равно 1
a.lastlndexOf(1); // => 3: а [3] равно 1

//includes
let a = [1, true, 3, NaN];
a.includes(true); // => true

//sort()
let а = ["banana", "cherry", "apple"];
a.sort(); // a ~ [ "apple", "banana", "cherry"]
let а = [33, 4, 1111, 222];
a.sort((a, b) => b - а); //а == [1111, 222, 33, 4]; обратный числовой порядок

а.sort(function (s, t) {
  let a = s.toLowerCase();
  let b = t.toLowerCase();
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}); // a == ["ant","Bug","cat","Dog"]; сортировка,
// нечувствительная к регистру

//reverse()
let а = [1, 2, 3];
a.reverse(); // а == [3,2,1]

//join()
let а = [1, 2, 3];
a.join(); // => ”1,2,3”

//isArray
//Статические
Array.isArray([]); // => true
Array.isArray({}); //=> false

//___Объекты, похожие на массивы
let а = {}; // Начать с обыкновенного пустого объекта
// Добавить свойства, чтобы сделать его "похожим на массив"
let i = 0;
while (i < 10) {
  a[i] = i * i;
  i++;
}
a.length = i;
// Выполнить итерацию по нему, как если бы он был настоящим массивом
let total = 0;
for (let j = 0; j < a.length; j++) {
  total += a[j];
}

//document.querySelectorAll() - возвращают объекты, похожие на массивы

let а = { 0: "а", 1: "Ь", 2: "с", length: 3 }; // Объект, похожий на массив
Array.prototype.map.call(a, (x) => x.toUpperCase()); // => ["А","В","C"]

//Строки как массивы
let s = "test";
s.charAt(0); // => "t"
s[l]; // => ”e"

//---------------------------------
//____________Функции____________//

//____Определение функций

//Объявления функций
function factorial(х) {
  if (х <= 1) return 1;
  return х * factorial(х - 1);
}

//Выражения функций
// Обратите внимание, что м ы присваиваем ее переменной,
const square = function (х) {
  return х * х;
};

//Стрелочные функции
const sum = (х, у) => {
  return х + у;
};

//Вложенные функции
//они могут получать доступ к параметрам и переменным функции внутрь которой вложены
function hypotenuse(а, b) {
  function square(х) {
    return х * х;
  }
  return Math.sqrt(square(a) + square(b));
}

//___Вызов функций
//как функции
//как методы
//как конструкторы
//косвенно посредством их методов call() и apply();
//неявно через языковые средства JavaScript

//в строгом режиме контекстом вызова(this) является undefined,в нестрогом режиме глобальный объект

//Вызов функции
printprops({ х: 1 });
let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5);
let probability = factorial(5) / factorial(13);

//_Вызов метода
//Метод — это не более чем функция JavaScript, которая хранится в свойстве объекта
let calculator = {
  // Объектный литерал
  operandl: 1,
  operand2: 1,
  add() {
    // Для этой функции мы используем сокращенный
    // синтаксис методов
    // Обратите внимание на применение ключевого слова this
    // для ссылки на вмещающий объект.
    this.result = this.operandl + this.operand2;
  },
};
calculator.add(); // Вызов метода для вычисления 1+1
calculator.result; // => 2

о["m"](х, у); // Еще один способ записи о.т(х,у)

//Формирование цепочек методов
//Когда методы возвращают объекты, возвращаемое значение одного вызова метода можно применять как часть дальнейшего вызова.
//Последовательно запустить три асинхронных операции, обрабатывая ошибки
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);

let o = {
  m: function () {
    //Метод m объекта
    let self = this; //Сохранить значение this в переменной
    this === 0; //true: this является объектом о
    f(); //Теперь вызвать вспомогательную функцию f (
    function f() {
      //Вложенная функция f
      this === 0; //=> false: this является глобальным объектом или undefined
      self === 0; //=> true: self является внешним значением this
    }
  },
};
o.m(); //Вызвать метод m на объект

//способ обхода проблемы c передачей this
const f = () => {
  this === о; // true, поскольку стрелочные функции наследуют this
};

//Другой обходной путь
const f = function () {
  this === о; //true, поскольку мы привязали эту функцию к внешнему this
}.bind(this);

//_Вызов конструктора
о = new Object();
о = new Object();

//_Необязательные параметры и стандартные значения
// Присоединяет имена перечислимых свойств объекта о к массиву а и возвращает а.
// Если аргумент а опущен, тогда создает и возвращает новый массив.
function getPropertyNames(о, а = []) {
  for (let property in о) a.push(property);
  return a;
}

// Эта функция возвращает объект, представляющий размеры прямоугольника.
// Если предоставляется только ширина, тогда сделать его высоту вдвое
// больше, чем ширину.
const rectangle = (width, height = width * 2) => ({ width, height });
rectangle(1); // => { width: 1, height: 2 }

//_Параметры остатка и списки аргументов переменной длины
function max(first = -Infinity, ...rest) {
  let maxValue = first; // Начать с предположения, что первый
  // аргумент самый большой
  // Затем пройти в цикле по оставшимся аргументам
  // в поисках наибольшего из них
  for (let n of rest) {
    if (n > maxValue) {
      maxValue = n;
    }
  }
  // Возвратить наибольший аргумент
  return maxValue;
}
max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // => 1000

//_Объект Arguments
//заменить его параметром остатка ...args
function max(х) {
  let maxValue = -Infinity;
  //Пройти в цикле по аргументам в поисках наибольшего и запомнить его
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > maxValue) maxValue = arguments[i];
  }
  // Возвратить наибольший аргумент
  return maxValue;
}
max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // => 1000

//_Операция распространения для вызовов функций
let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers); // => -1

//_ Деструктуризация аргументов функции в параметры
function vectorAdd(
  { х: x1, у: y1 }, // Распаковать 1-й объект в параметры xl и у1
  { х: х2, у: у2 } // Распаковать 2-й объект в параметры х2 и у2
) {
  return { х: x1 + х2, у: y1 + у2 };
}
vectorAdd({ x: 1, у: 2 }, { х: 3, у: 4 }); // => {х: 4, у: 6}

//Эта функция ожидает аргумент типа массива.
// Первые два элемента массива распаковываются в параметры х и у.
// Любые оставшиеся элементы сохраняются в массиве coords.
// Любые аргументы после первого массива упаковываются в массив rest.
function f([х, у, ...coords], ...rest) {
  return [x + y, ...rest, __coords];
  // Примечание: здесь используется операция распространения
}
f([1, 2, 3, 4], 5, 6); // => [3, 5, 6, 3, 4]

//____Функции как значения
function square(х) {
  return х * х;
}
let s = square; // Теперь s ссылается на ту же функцию, что и square

let о = {
  square: function (х) {
    return х * х;
  },
}; // Объектный литерал
let у = о.square(16); // у == 256

let а = [(х) => х * х, 20]; // Литерал типа массива
a[0](а[1]); // => 400

//Использование функций как данных
function add(x, y) {
  return х + у;
}
function subtract(х, у) {
  return х - у;
}
function multiply(х, у) {
  return х * у;
}
function divide(х, у) {
  return х / у;
}
// Функция, которая принимает одну из определенных выше функций
// в качестве аргумента и вызывает ее с двумя операндами
function operate(operator, operandl, operand2) {
  return operator(operandl, operand2);
}

//_Определение собственных свойств функций
uniqueInteger.counter = 0;
function uniquelnteger() {
  return uniquelnteger.counter++; // Возвратить и инкрементировать свойство counter
}
uniquelnteger(); // => 0
uniquelnteger(); // => 1

//_Функции как пространства имен
//Переменные, объявленные внутри функции, за ее пределами не видны
function chunkNamespace() {
  // Фрагмент многократно используемого кода.
  // Любые определяемые здесь переменные являются локальными
  //по отношению к этой функции и не загромождают глобальное
  // пространство имен.
}
chunkNamespace(); // Но не забудьте вызвать функцию!

(function () {
  // Функция chunkNamespace(), переписанная
  // в виде неименованного выражения
  // Фрагмент многократно используемого кода
})(); // Конец литерала типа функции и его вызов

//_Замыкания
// функции выполняются с применением области видимости переменных, которая действовала, когда они были определены, а не когда вызваны.
let scope = "глобальная область видимости"; // Глобальная переменная
function checkscope() {
  let scope = "локальная область видимости"; // Локальная переменная
  function f() {
    return scope;
  } // Возвратить значение scope
  return f();
}
checkscope(); // => "локальная область видимости"

let uniquelnteger = (function () {
  // Определить и вызвать
  let counter = 0; // Закрытое состояние функции ниже
  return function () {
    return counter++;
  };
})();
uniquelnteger(); // => 0
uniquelnteger(); // => 1

//_Свойства и методы и конструктор функций

//Свойство length
//количество параметров

//Свойство name
//имя, которое использовалось при определении функции

//Свойство prototype
//ссылается на объект, известный как объект прототипа

//_Методы call() и apply()
//представляет контекст вызова и становится значением ключевого слова this внутри тела функции
f.call(о, 1, 2);

//аргументы указываются в виде массива
f.apply(о, [1, 2]);

//_Метод bind()
//привязка функции к объекту
function f(у) {
  return this.x + у;
} //Этой функции необходима привязка
let о = { х: 1 }; // Объект, к которому будет осуществляться привязка
let g = f.bind(о); // Вызов g(x) приводит к вызову f() на о
9(2); // = > 3

//_ Конструктор Function()
const f = new Function("х" / "у", "return x * y; ");

//_Функции высшего порядка
//функция, которая оперирует функциями,принимая одну или большее количество функций в качестве аргументов и возвращая новую функцию
function mapper(f) {
  return (a) => map(a, f);
}
const increment = (x) => x + 1;
const incrementAll = mapper(increment);
incrementAll([1, 2, 3]); // => [2,3,4]

function compose(f, g) {
  return function (...args) {
    // Мы используем call для f, потому что передаем одиночное значение,
    // и apply для д, поскольку передаем массив значений,
    return f.call(this, g.apply(this, args));
  };
}
const sum = (x, y) => x + y;
const square = (x) => x * x;
compose(square, sum)(2, 3); // => 25; квадрат суммы

//_Функции с частичным применением
// Аргументы этой функции передаются справа
function partialRight(f, ...outerArgs) {
  return function (...innerArgs) {
    // Возвратить эту функцию
    let args = [...innerArgs, ...outerArgs]; // Построить список
    // аргументов
    return f.apply(this, args); // Затем вызвать с ним функцию f
  };
}

//_Мемоизация
// Возвращает мемоизованную версию f . Работает, только если все
// аргументы f имеют отличающиеся строковые представления,
function memoize(f) {
  const cache = new Map(); // Кеш значений хранится в замыкании
  return function (...args) {
    // Создать строковую версию аргументов для использования
    // в качестве ключа кеша
    let key = args.length + args.join("+");
    if (cache.has(key)) {
      return cache.get(key);
    } else {
      let result = f.apply(this, args);
      cache.set(key, result);
      return result;
    }
  };
}

//--------------------------------------
//______________Классы________________//
//Классы в JavaScript используют наследование, основанное на прототипах

//_Классы и прототипы
// Фабричная функция, которая возвращает новый объект диапазона,
function range(from, to) {
  // Использовать Object.create() для создания объекта, который наследуется
  //от объекта прототипа, определенного ниже. Объект прототипа хранится как
  // свойство этой функции и определяет разделяемые методы (поведение)
  // для всех объектов, представляющих диапазоны,
  let г = Object.create(range.methods);
  // Сохранить начальную и конечную точки (состояние) нового объекта диапазона.
  // Эти свойства не являются унаследованными и они уникальны для этого объекта,
  г.from = from;
  г.to = to;
  // В заключение возвратить новый объект,
  return г;
}

range.methods = {
  // Возвращает true, если х входит в диапазон, и false в противном случае.
  // Метод работает как с числовыми, так и с текстовыми диапазонами
  // и диапазонами Date.
  includes(х) {
    return this.from <= x && x <= this.to;
  },
  //Обратите внимание, что она работает только с числовыми диапазонами.
  *[Symbol.iterator]() {
    for (let x = Math.ceil(this, from); x <= this, to; x++) yield x;
  },
  // Возвращает строковое представление диапазона.
  toString() {
    return " (" + this, from + "..." + this, to + ")";
  },
};
let г = range(1, 3); // Создать объект диапазона
r.includes(2); // => true: 2 входит в диапазон
j.toString(); // => "(1...3)"

//_Классы и конструкторы
//Вызов конструктора автоматически создает новый объект
function Range(from, to) {
  // Сохранить начальную и конечную точки (состояние) нового объекта диапазона.
  // Эти свойства не являются унаследованными и они уникальны для этого объекта.
  this, (from = from);
  this, (to = to);
}

Range.prototype *
  {
    // Возвращает true, если х входит в диапазон, и false в противном случае.
    // Метод работает как с числовыми, так и с текстовыми диапазонами
    // и диапазонами Date.
    includes: function (х) {
      return this.from <= x && x <= this.to;
    },
    //Генераторная функция, которая делает экземпляры класса итерируемыми. обратите внимание, что она работает только с числовыми диапазонами.
    [Symbol.iterator]: function* () {
      for (let x = Math.ceil(this, from); x <= this, to; x++) yield x;
    },
    // Возвращает строковое представление диапазона.
    toString: function () {
      return "(" + this.from + "..." + this.to + "";
    },
  };
let r = new Range(1, 3); // Создать объект Range; здесь применяется new
includes(2); // => true: 2 входит в диапазон
r.toString(); // -> "(1...3)"

//_Свойство constructor
//Значением свойства prototype будет объект, который имеет единственное неперечислимое свойство constructor
let F = function () {}; // Объект функции
let р = F.prototype; // Объект прототипа, ассоциированный с F
let c = p.constructor; // Функция, ассоциированная с прототипом
c === F; // => true: F.prototype.constructor === F
// для любого объекта F

let о = new F(); // Создать объект о класса F
o.constructor === F; // => true: свойство constructor указывает класс

Range.prototype = {
  constructor: Range, //Явно установить обратную ссылку на конструктор
  /* далее идут определения методов */
};

//_ Классы с ключевым словом class
//неявно подчиняется требованиям строгого режима
//синтаксический сахар

class Range {
  constructor(from, to) {
    // Сохранить начальную и конечную точки (состояние)
    // нового объекта диапазона.
    // Эти свойства не являются унаследованными и они уникальны
    // для этого объекта,
    this, (from = from);
    this, (to = to);
  }
  // Возвращает true, если x входит в диапазон, и false в противном
  // случае. Метод работает как с числовыми, так и с текстовыми
  // диапазонами и диапазонами Date.
  includes(х) {
    return this.from <= x && x <= this.to;
  }
  // Генераторная функция, которая делает экземпляры класса итерируемыми.
  // Обратите внимание, что она работает только с числовыми диапазонами.
  *[Symbol.iterator]() {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  }
  // Возвращает строковое представление диапазона.
  toString() {
    return `(${this.from}...${this.to}) `;
  }
}
// пример использования нового класса Range.
let г = new Range(1, 3); // Создать объект Range
r.includes(2); // => true: 2 входит в диапазон
r.toString(); // => "(1...3)"

let Square = class {
  constructor(х) {
    this.area = x * x;
  }
};
new Square(3).area; // => 9

//_Открытые, закрытые и статические поля
class Buffer {
  size = 0;
  capacity = 4096;
  buffer = new Uint8Array(this.capacity);
}

//не сумеют случайно модифицировать поле size
class Buffer {
  #size = 0;
  get size() {
    return this.#size;
  }
}

//___Добавление методов в существующие классы
//Механизм наследования на основе прототипов JavaScript является динамическим: объект наследует свойства от своего прототипа, даже если свойства прототипа изменяются после создания объекта

//___Подклассы

//_Подклассы и прототипы
// Функция конструктора для нашего подкласса,
function Span(start, span) {
  if (span >= 0) {
    this.from = start;
    this, (to = start + span);
  } else {
    this.to = start;
    this, (from = start + span);
  }
}
// Обеспечить, чтобы прототип Span наследовался от прототипа Range.
Span.prototype = Object.create(Range.prototype);
// Мы не хотим наследовать Range.prototype.constructor, поэтому
// определяем собственное свойство constructor.
Span.prototype.constructor = Span;
//За счет определения собственного метода toString() подкласс Span
// переопределяет метод toString(), который иначе он унаследовал бы от Range*
Span.prototype.toString = function () {
  return `($(this.from}... +${this.to - this.from}) `;
};

//_ Создание подклассов с использованием extends и super
class EZArray extends Array {
  get first() {
    return this[0];
  }
  get last() {
    return this[this.length - 1];
  }
}
let a = new EZArray();
a instanceof EZArray; //=> true: a - экземпляр подкласса
a instanceof Array; //=> true: a - также экземпляр суперкласса
a.push(1, 2, 3, 4); //a.length == 4; можно использовать унаследованные методы

// EZArray наследует методы экземпляра, поскольку EZArray.prototype
// наследуется от Array.prototype.
Array.prototype.isPrototypeOf(EZArray.prototype); // => true

// Вдобавок EZArray наследует статические методы и свойства, потому что
// EZArray наследуется от Array. Это специальная возможность ключевого
// слова extends, которая не была доступна до выхода ES6.
Array.isPrototypeOf(EZArray); // => true

class TypedMap extends Map {
  constructor(keyType, valueType, entries) {
    // Если записи entries определены, тогда проверить их типы,
    if (entries) {
      for (let [k, v] of entries) {
        if (typeof к !== keyType || typeof v !== valueType) {
          throw new TypeError("Неправильный тип для записи [${k}, ${v}]");
        }
      }
    }
    //Инициализировать суперкласс начальными записями (с проверенными типами)
    super(entries);
    // Затем инициализировать подкласс this, сохранив типы,
    this.keyType = keyType;
    this.valueType = valueType;
  }
}

//_Делегирование вместо наследования
//отдавать предпочтение делегированию перед наследованием
class Histogram {
  // Для инициализации мы просто создаем объект Мар,
  // чтобы делегировать ему выполнение работы,
  constructor() {
    this.map = new Map();
  }
  // Для любого заданного ключа счетчик - это значение
  // в объекте Мар или ноль, если ключ в Мар отсутствует.
  count(key) {
    return this.map.get(key) || 0;
  }
  // Метод has() как в классе Set возвращает true в случае ненулевого счетчика,
  has(key) {
    return this.count(key) > 0;
  }
}

//_Иерархии классов и абстрактные классы
//Абстрактный суперкласс может определять частичную реализацию, которУ10 наследуют и разделяют все подклассы

//Класс AbstractSet определяет единственный абстрактный метод has()
class AbstractSet {
  // Сгенерировать ошибку, чтобы заставить подклассы определять
  // собственную работающую версию этого метода.
  has(x) {
    throw new Error("Абстрактный метод");
  }
}

class RangeSet extends AbstractSet {
  constructor(from, to) {
    super();
    this, (from = from);
    this.to * to;
  }
  // Наша реализация унаследованного абстрактного метода
  has(x) {
    return x >= this.from && x <= this.to;
  }
  toString() {
    return `{ x| ${this.from} £ x £ ${this.to} `;
  }
}

//----------------------------------------
//________________Модули________________//
//позволить собирать крупные программы с использованием модулей кода
//На практике модульность главным образом касается инкапсуляции или сокрытия внутренних деталей

//___Модули, использующие классы, объекты и замыкания
// Вот так мы могли бы определить модуль расчета статистических данных.
const stats = (function () {
  // Служебные функции закрыты по отношению к модулю,
  const sum = (х, у) => х + у;
  const square = (х) => х * х;
  // Открытая функция, которая будет экспортироваться,
  function mean(data) {
    return data.reduce(sum) / data.length;
  }
  // Открытая функция, которая будет экспортироваться,
  function stddev(data) {
    let m = mean(data);
    return (
      Math,
      sqrt(
        data
          .map((x) => x - m)
          .map(square)
          .reduce(sum) /
          (data.length - 1)
      )
    );
  }
  // Открытые функции экспортируются в виде свойств объекта,
  return {
    mean,
    stddev,
  };
})();
//А так м ы можем использовать модуль.
stats.mean([1, 3, 5, 7, 9]); // => 5
stats.stddev([1, 3, 5, 7, 9]); //=> Math, sqrt (10)

//___Модули в Node

//_Экспортирование в Node
const sum = (х, у) => х + у;
const square = (х) => х * х;
exports.mean = (data) => data.reduce(sum) / data.length;
exports.stddev = function (d) {
  let m = exports.mean(d);
  return Math.sqrt(
    d
      .map((x) => x - m)
      .map(square)
      .reduce(sum) /
      (d.length - 1)
  );
};

//экспортирует только одну функцию или класс
module.exports = class BitSet extends AbstractWritableSet {
  // реализация не показана
};

// Определить все функции, открытые и закрытые.
const sum = (х, у) => х + у;
const square = (х) => х * х;
const mean = (data) => data.reduce(sum) / data.length;
const stddev = (d) => {
  let m = mean(d);
  return Math.sqrt(
    d
      .map((x) => x - m)
      .map(square)
      .reduce(sum) /
      (d.length - 1)
  );
};
// Теперь экспортировать только открытые функции.
module.exports = { mean, stddev };

//_Импортирование в Node
// Эти модули встроены в Node.
const fs = require("fs"); // Встроенный модуль файловой системы
const http = require("http"); // Встроенный модуль HTTP

//импортировать модуль собственного кода
//можете опускать суффикс .js
const stats = require("./stats.js");
const BitSet = require("./utils/bitset.js");

const { stddev } = require("./stats.js");

//___Модули в ES6
//каждый файл имеет собственный закрытый контекст
//"use strict" по умолчанию

//_Экспортирование в ES6
export const PI = Math.PI;
export function degreesToRadians(d) {
  return (d * PI) / 180;
}
export class Circle {
  constructor(r) {
    this.r = r;
  }
  area() {
    return PI * this.r * this.r;
  }
}
//export { Circle, degreesToRadians, PI };

//экспортируют только одно значение
export default class BitSet {
  // реализация не показана
}

//_ Импортирование в ES6
//default
import BitSet from "./bitset.js";

import { mean, stddev } from " ./stats.js";

//через объект stats, вызывая их как stats.mean() и stats.stddev()
import * as stats from "./stats.js";

//cмешанный импорт
import Histogram, { mean, stddev } from " ./histogram-stats.js";

//используется с модулями, вообще не имеющими операторов экспорта
import " ./analytics.js";

//_Импортирование и экспортирование с переименованием
import { render as renderlmage } from "./imageutils. js";
import { render as renderUI } from " ./ui. js";
import { default as Histogram, mean, stddev } from ". /histogram-stats, js";

//_Повторное экспортирование
import { mean } from "./stats/mean. js";
import { stddev } from "./stats/stddev.js";
export { mean, stdev };

//экспортировать из другого модуля все именованные значения
export * from "./stats/mean.js";
export * from " ./stats/stddev.js";

//____Модули JavaScript для веб-сети

//выполняются подобно сценариям с атрибутом defer
//выполнение кода не начнется до тех пор, пока не закончится синтаксический анализ HTML - разметки
//<script type="module">import "./main. js";</script>

//async будет выполняться, как только загрузится код, даже если синтаксический анализ HTML-разметки не закончен

//Динамическое импортирование с помощью import()
import * as stats from ". /stats.js";

import(". /stats.js").then((stats) => {
  let average = stats.mean(data);
});

//-----------------------------------------
//____Стандартная библиотека JavaScript___//

//_Множества и отображения
//Object

//_Класс Set
//является итерируемым
let t = new Set(s); // Новое множество, которое
// копирует элементы s.
let unique = new Set("Mississippi"); //4 элемента: "M", "i"f "s" и "p"

let s = new Set(); // Начать с пустого множества
s.size; // => О
s.add(1); // Добавить число
s.size; // => 1; теперь множество имеет один член
s.add(1); // Добавить то же самое число еще раз
s.size; // => 1; размер не изменился
s.add(true); // Добавить другое значение; обратите внимание на допустимость смешивания типов => 2
s.delete(1); // => true: успешное удаление элемента 1
s.clear(); // Удалить все из множества

//является ли указанное значение членом множества
let oneDigitPrimes = new Set([12, 3, 5, 7]);
oneDigitPrimes.has(2); // => true: 2 - простое число с одной цифрой

let sum = 0;
for (let p of oneDigitPrimes) {
  // Пройти по простым числам с одной
  sum += р; // цифрой и сложить их
}
sum; // => 17: 2 + 3 + 5 + 7

//_ Класс Мар
let m = new Мар(); // Новое пустое отображение
let n = new Мар([
  // Новое отображение, которое инициализировано
  // строковыми ключами, отображенными на числа
  ["one", 1],
  ["two", 2],
]);
let о = { х: 1, у: 2 }; // Объект с двумя свойствами
let р = new Map(Object.entries(о)); // То же, что и
// new m a p ([["х", 1], ["у", 2]])

let m = new Мар();
m.size; //0
m.set("one", 1);
m.set("two", 2);
m.size; //2
m.get("two"); //2
m.get("three"); //undefined
m.set("one", true); //Изменить значение
m.size; //2
m.has("one"); //true: отображение имеет ключ "one"
m.has(true); //false: отображение не содержит ключа true
m.delete("one"); //=> true: ключ существует, и удаление проходит успешно
m.size; // => 1
m.delete("three"); // => false: не удалось удалить несуществующий ключ
m.clear(); // Удалить все ключи и значения из отображения

//можно выстраивать в цепочки
let m = new Map().set("one", 1).set("two", 2).set(" th ree ", 3);

let m = new Map([
  ["x", 1],
  ["у", 2],
]);
[...m]; // => [["x", 1], ["у”, 2]]
for (let [key, value] of m) {
  //На первой итерации ключом будет "х", а значением - 1
  //На второй итерации ключом будет "у", а значением - 2
}

[...m.keys()]; //=> ["х", "у"]: только ключи
[...m.values()]; // => [1, 2]: только значения
[...m.entries()]; //=> [["х", 1], ["у”, 2]]: тоже, что и [...т]

//_WeakMap и WeakSet
//WeakMap хранит “слабые” ссылки сборщик мусора не удаляет их

//Конструктор WeakMap() похож на конструктор Мар()
//Ключи обязаны быть объектами или массивами
//WeakMap реализует только методы get(), set(), has() и delete()
//не является итерируемым
//не реализует свойство size

//Класс WeakSet реализует множество объектов, которые не препятствуют оба6отке этих объектов сборщиком мусора.

//_Типизированные массивы и двоичные данные
//Int8Array() - байты со знаком / Uint8Array() - байты без знака ...
let bytes = new Uint8Array(1024); // Буфер размером 1 килобайт
let pattern = new Uint8Array([0, 1, 2, 3]); // Массив из 4 байтов
bytes.set(pattern); //Копировать их в начало другого байтового массива
bytes, set(pattern, 4); // Копировать их снова по другому смещению
bytes.set([0, 1, 2, 3], 8); // Или просто копировать значения прямо
//из обыкновенного массива
bytes.slice(0, 12); // => new Uint8Array([0,1,2,3,0,1,2,3,0,1,2,3])

//Класс DataView определяет десять методов получения для десяти классов типизированных массивов

//_Регулярное выражение
// объект, который описывает текстовый шаблон
"7 plus 8 equals 15".match(/\d+/g); // => ["7", "8", "15"]

//_Дата и время
let epoch = new Date(0); // Полночь, 1 января 1970 года,  гринвичское среднее время

let d = new Date();
setMonth(d.getMonth() + 3, d.getDateO + 14);

//_ Классы ошибок
class HTTPError extends Error {
  constructor(status, statusText, url) {
    super("${status} ${statusText}: ${url}");
    this.status = status;
    this.statusText = statusText;
    this.url = url;
  }
  get name() {
    return "HTTPError";
  }
}

//_Сериализация и разбор данных в формате JS0N
let о = { s: "", n: 0, a: [true, false, null] };
let s = JSON.stringify(o); //s = ' {"s,,:,f", "n":0, "a": [true,false,null]}'
let copy = JSON.parse(s); //copy = {s:"”, n:0, a: [true, false, null]}

//_API-интерфейс интернационализации
//Intl.NumberFormat, Inti.DateTimeFormat и Inti.Col lator

//_Форматирование чисел
let euros = Inti.NumberFormat("es", {
  style: "currency",
  currency: "EUR",
}).euros.format(10); // => "10,00 €": десять евро, испанское форматирование

let data = [0.05, 0.75, 1];
let formatData = Intl.NumberFormat(undefined, {
  style: "percent",
  minimumFractionDigits: 1,
  maximumFractionDigits: 1,
}).format;
data.map(formatData); // => ["5.0%", "75.0%", "100.0%"]: в локали en-US

//_Форматирование даты и времени
let d = new Date("2020-01-02T13:14:15Z");
Intl.DateTimeFormat("en-US").format(d); // => "1/2/2020"

// Время в Нью-Йорке для франкоговорящих канадцев
opts =
  { hour: "numeric", minute: "2-digit", timeZone: "America/New__York" } /
  Intl.DateTimeFormat("fr-CA", opts).format(d); // => "8 h 14"

//_Сравнение строк
//Если вы хотите отображать строки пользователю в порядке, который он сочтет естественным, тогда использования метода sort() на массиве строк будет недостаточно

// Базовый компаратор для сортировки согласно локали пользователя.
// Никогда не сортируйте строки, читабельные человеком, без передачи чего - то вроде такого:
const collator = new Inti.Collator().compare;
["a", "z", "A", "Z"].sort(collator); // => ["a", "A”, "z", ”Z"]

// Имена файлов часто включают числа, поэтому мы должны их
// сортировать особым образом:
const filenameOrder = new Inti.Collator(undefined, { numeric: true }).compare;
["page 10", "page9"].sort(filenameOrder); // => ["page9", "pagelO”]

//_API-интерфейс Console
//console.debug( ), console.info( ), console.warn( ) , console.error( ) ....

//_API-интерфейсы URL

//разбирает URL
let url = new URL("https://example.com:8000/path/name?q=term#fragment");
url.href; // => "https://example.com:8000/path/name?q=term#fragment"
url.origin; // => "https://example.com:8000"
url.protocol; // => "https:"
url.host; // => "example.com:8000"
url.hostname; // => "example.com"
url.port; // => "8000"
url.pathname; // => "/path/name”
url.search; // => "?q=term"
url.hash; // => "#fragment"

//закодировать пары имя/значение подобного рода в виде порции запроса URL
let url = new URL("https://example.com/search");
url.search; // => пока запроса нет
url.searchParams.append("q", "term"); // Добавить параметр поиска
url.search; // => "?q=term"
url.searchParams.set("q", "x"); // Изменить значение этого параметра
url.search; // => "?q=x"
url.searchParams.get("q"); // => "x": запросить значение параметра
url.searchParams.has("q"); // => true: имеется параметр q
url.searchParams.has("p"); // => false: параметр p отсутствует

//encodeURI() и decodeURI() . Функция encodeU RI () принимает в своем аргументе строку и возвращает новую строку, в которой закодированы символы, отличающиеся от ASCII

//encodeURIComponentO и decodeURIComponent ( ) . Данные две функции работают подобно encodeU RI() и decodeU R I(), но они предназначены для кодирования индивидуальных компонентов URI, а потому также кодируют управляющие символы вроде /, ? и #, которые используются для отделения этих компонентов

//_Таймеры
setTimeout(() => {
  console.log("Ready...");
}, 1000);

// Раз в секунду: очистить консоль и вывести текущее время.
let clock = setlnterval(() => {
  console.clear();
  console.log(new Date().toLocaleTimeString());
}, 1000);
// Спустя 10 секунд: прекратить повторение выполнения кода выше.
setTimeout(() => {
  clearlnterval(clock);
}, 10000);

//----------------------------------
//___Итераторы и генераторы___//

//_Особенности работы итераторов
//Итерируемый объект — это любой объект со специальным итераторным методом, который возвращает объект итератор
//особенность генераторов заключается в том, что они позволяют приостанавливать вычисление, выдавать промежуточные результаты и позже возобновлять вычисление

//цикл for/of по итерируемому объекту iterable
let iterable = [99];
let iterator = iterable[Symbol.iterator]();
for (let result = iterator.next(); !result.done; result = iterator.next()) {
  console.log(result.value); // result.value == 99
}

let list = [1, 2, 3, 4, 5];
let iter = list[Symbol.iterator]();
let head = iter.next().value; // head == 1
let tail = [...iter]; // tail == [2,3,4,5]

//_ Генераторы
//function* , yield вместо return()
function* oneDigitPrimes() {
  // При вызове этой функции код не выполняется, а просто возвращается объект генератора
  yield 2;
  yield 3;
  yield 5;
  yield 7;
  // Вызов метода next() данного генератора приводит к выполнению кода до тех пор, пока оператор yield не предоставит возвращаемое значение для метода next () .
}
primes.next().value; // => 2
primes.next().value; // => 3
primes.next().value; // => 5
primes.next().value; // => 7
Primes.next().done; // => true

//// Мы можем использовать генераторы подобно другим итерируемым типам
for (let prime of oneDigitPrimes()) sum += prime;
sum; // => 17

const seq = function* (from, to) {
  for (let i = from; i <= to; i++) yield i;
};
[...seq(3, 5)]; // => [3, 4, 5]

//сокращенную запись
let о = {
  х: 1,
  у: 2,
  z: 3,
  // Генератор, который выдает каждый ключ этого объекта.
  *q() {
    for (let key of Object.keys(this)) {
      yield key;
    }
  },
};
[...o.g()]; // => ["x", "y", "z"

//записать генераторную функцию с применением синтаксиса стрелочных функций не удастся

// throw() исключения или преждевременный выход из функции

//---------------------------------
//___-Асинхронный JavaScript______//
//асинхронное программирование JavaScript производится с помощью обратных вызовов

//_Таймеры
//запустить какой-то код по истечении определенного времени

//_События
//ожидают, пока пользователь что-то сделает, после чего реагируют на действия пользователя

//_События сети
//сетевые запросы

//_Обратные вызовы и события в Node
//Node.js глубоко асинхронна и определяет многочисленные API - интерфейсы, в которых применяются обратные вызовы и события

const fs = require("fs"); // Модуль fs содержит А Р I-интерфейсы,
// связанные с файловой системой.
let options = {
  // Объект для хранения параметров для нашей программы.
  // Здесь задаются параметры по умолчанию.
};
//Прочитать конфигурационный файл, затем вызвать функцию обратного вызова
fs.readFile("config.json", "utf-8", (err, text) => {
  if (err) {
    //Если возникла ошибка, тогда отобразить предупреждение, но продолжить
    console.warn("Could not read config file:", err);
    //He удалось прочитать конфигурационный файл
  } else {
    // В противном случае произвести разбор содержимого файла
    // и присвоить объекту параметров.
    Object.assign(options, JSON.parse(text));
  }
  // В любом случае теперь мы можем начать выполнение программы,
  startProgram(options);
});

//___Объекты Promise
//можно выстраивать в цепочки -  цепочкой методов
//вызов метода then() обязан возвращать объект Promise

fetch("/api/user/profile") // Начать HTTP-запрос.
  .then((response) => {
    //Вызывается, когда готовы состояние и заголовки,
    if (!response.ok) {
      // Если м ы получаем ошибку
      // 404 Not Found или похожую.
      return null; // Возможно, пользователь вышел из системы;
      // возвратить профиль null.
    }
    // Проверить заголовки, чтобы удостовериться,
    // что сервер отправил нам JSON.
    // Если нет, тогда наш сервер неисправен, а это серьезная ошибка!
    let type = response.headers.get("content-type");
    if (type !== "application/json") {
      throw new TypeError("Expected JSON, got ${type}");
    }
    // Ожидался JSON, но получен другой тип
    // Если мы попали сюда, то получили состояние 2хх
    // и тип содержимого JSON, поэтому можем уверенно возвратить
    // объект Promise для тела ответа как объект JSON.
    return response.json();
  })
  .then((profile) => {
    //Вызывается с разобранным телом ответа или null
    if (profile) {
      displayUserProfile(profile);
    } else {
      // Если мы получили ошибку 404 выше
      // и возвратили null, то окажемся здесь.
      displayLoggedOutProfilePage();
    }
  })
  .catch((е) => {
    if (е instanceof NetworkError) {
      // fetch () может потерпеть такую неудачу,
      // если исчезло подключение к Интернету.
      displayErrorMessage("Check your internet connection.");
      // Проверьте свое подключение к Интернету.
    } else if (е instanceof TypeError) {
      // Это происходит в случае генерации TypeError выше.
      displayErrorMessage("Something is wrong with our server!");
      // Что-то не так с нашим сервером!
    } else {
      // Это должна быть непредвиденная ошибка какого-то вида,
      console.error(е);
    }
  });

//_Параллельное выполнение нескольких асинхронных операций с помощью Promise

//Promise.all(), котораяпринимает на входе массив объектов P rom ise и возвращает объект Promise ,Promise будет отклонен, если отклонен любой из входных объектов Promise

//Мы начинаем с массива URL.
const urls = [
  /* ноль или большее количество URL */
];
// И преобразуем его в массив объектов Promise.
promises = urls.map((url) => fetch(url).then((r) => r.textf));
//Теперь получаем объект Promise для запуска всех объектов Promise параллельно
Promise.all(promises)
  .then((bodies) => {
    /* делать что-нибудь с массивом строк */
  })
  .catch((е) => console.error(е));

//Promise.allSettled - никогда не отклоняет возвращенный объект P romise и не удовлетворяет его до тех пор, пока не будут урегулированы все входные объекты Promise
Promise.allSettled([Promise.resolve(1), Promise.reject(2), 3]).then(
  (results) => {
    results[0]; // => { status: "fulfilled", value: 1 }
    results[1]; // => { status: "rejected", reason: 2 )
    results[2]; // => { status: "fulfilled", value: 3 }
  }
);

//значение вычисляется синхронно и возвращается асинхронно
Promise.resolve();
Promise.reject();

//_Объекты Promise с нуля
function wait(duration) {
  // Создать и возвратить новый объект Promise.
  return new Promise((resolve, reject) => {
    // Это контролирует
    // объект Promise.
    //Если значение аргумента недопустимо, тогда отклонить объект Promise
    if (duration < 0) {
      reject(new Error("Time travel not yet implemented"));
    }
    // Путешествия во времени пока не осуществимы
    // В противном случае асинхронно ожидать и затем разрешить
    // объект Promise.
    //setTimeout будет вызывать resolve()без аргументов, а это значит,
    // что объект Promise будет удовлетворен в значение undefined.
    setTimeout(resolve, duration);
  });
}

//___async и await
async function getHighScore() {
  let response = await fetch("/api/user/profile");
  let profile = await response.json();
  return profile.highScore;
}

//Ожидание множества объектов Promise
let valuel = await getJSON(urll);
let value2 = await getJSON(url2);
let [valuel, value2] = await Promise.all([getJSON(urll), getJSON(url2)]);

//_Цикл for / await
const fs = require("fs");
async function parseFile(filename) {
  let stream = fs.createReadStream(filename, { encoding: "utf-8" });
  for await (let chunk of stream) {
    parseChunk(chunk); // Функция parseChunk() определена
    // где-то в другом месте
  }
}

for (const promise of promises) {
  response = await promise;
  handle(responce);
}
//упростить код c for/await
for await (const response of promises) {
  handle(response);
}

//___Асинхронные генераторы
//[Symbol.asynclterator]()

function elapsedTime(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function* clock(interval, max = Infinity) {
  for (let count = 1; count <= max; count++) {
    // Обыкновенный цикл for
    await elapsedTime(interval); // Ожидать в течение
    // указанного времени.
    yield count; // Выдать счетчик.
  }
}

// Тестовая функция, которая использует асинхронный генератор
// с циклом for/await.
async function test() {
  //Асинхронная, поэтому можно применять for/await.
  for await (let tick of clock(300, 100)) {
    // Цикл 100 раз каждые
    // 300 миллисекунд.
    console.log(tick);
  }
}

//-----------------------------------
//______Метапрограммирование_______//
//расширенных возможносте й JavaScript, которы е обычно не прим еняю тся при повседневном программировании

//___Атрибуты свойств
//дескриптором свойств - writable (записываемое) / атрибут enumerable / атрибут configurable
let о = {};
// Добавить неперечислимое свойство данных х со значением 1.
Object.defineProperty(о, "х", {
  value: 1,
  writable: true,
  enumerable: false,
  configurable: true,
});

// более одного свойства за раз
let р = Object.defineProperties(
  {},
  {
    х: { value: 1, writable: true, enumerable: true, configurable: true },
    y: { value: 1, writable: true, enumerable: true, configurable: true },
    r: {
      get() {
        return Math, sqrt(this.x * this.x + this.y * this.y);
      },
      enumerable: true,
      configurable: true,
    },
  }
);
p.r; // => Math.SQRT2

//_Расширяемость объектов
//является ли объект расширяемым - Object.isExtensible()
//сделать нерасширяемым - Object.preventExtensions()

//_ Атрибут prototype
//А трибут prototype устанавливается, когда объект создается
//Объекты , созданные посредством new, применяют для своих прототипов значение свойства prototype функции конструктора

//запросить прототип
Object.getPrototypeOf({}); // => Obj e c t .prototype
Object.getPrototypeOf([]); // => Array.prototype
Object.getPrototypeOf(() => {}); // => Function.prototype

//определения, является ли один объект прототипом другого объекта
let р = { х: 1 }; // Определить объект прототипа.
let о = Object.create(р); // Создать объект с этим прототипом
р.isPrototypeOf(о); // => true: о наследуется из р
Object.prototype.isPrototypeOf(p); // из Object .prototype
Object.prototype.isPrototypeOf(о); // => true: о тоже

//прототип объекта можно изменять
let о = {
  х: 1,
};
let р = { у: 2 };
Object.setPrototypeOf(о, p); // Установить прототип объекта о в р.
о.у; // => 2: о теперь наследует свойство у
let а = [1 / 2 / 3] / Object.setPrototypeOf(a, p); // Установить прототип массива а в p
a.join; // => undefined: а больше не имеет метода join()

//свойство давно устарело - __proto__ / аналог prototype
let р = { z: 3 };
let о = {
  х: 1,
  У: 2,
  __proto__: р,
};
o.z; // => 3: о унаследован от р

//____Symbol

//проверка типов
let uint8 = {
  [Symbol.haslnstance](x) {
    return Number.islnteger(x) && x >= 0 && x <= 255;
  },
};
128 instanceof uint8; // => true
256 instanceof uint8; // => false: слишком большой
Math.PI instanceof uint8; // => false: не целый

//toString
Object.prototype.toString.call([]); // => "[object Array]"

//Symbol.species
//extends по коробкой
class EZArray extends Array {
  static get [Symbol.species]() {
    return Array;
  }
  get first() {
    return this[0];
  }
  get last() {
    return this[this.length - 1];
  }
}

//isConcatSpreadable
class NonSpreadableArray extends Array {
  get [Symbol.isConcatSpreadable]() {
    return false;
  }
}
let a = new NonSpreadableArray(1, 2, 3);
[].concat(a).length; // => 1; (в случае распространения длина
// составляла бы 3 элемента)
//...

//___API-интерфейс Reflect
Reflect.apply(f, о, args); // Эквивалентна f.appl(о , args)
//....

//___Объекты Proxy
//м огут исп ользоваться как необязательноаннулируем ы е оболочки для улучш ения ин кап суляц и и кода и такж е могут применяться для реализации нестандартных линий поведения объектов
//объект цели(target) и объект обработчиков(handlers)
let proxy = new Proxy(target, handlers);
let t = { х: 1, у: 2 };
let р = new Proxy(t, {});
р.х; // => 1
delete р.у; // => t r u e : уд ал яет свой ство у посредника
t.y; // => u n d e fin e d : у д ал яет е го также в объекте цели
р.z = 3; // Определение нового сво й ства в посреднике
t.z; // => 3: оп ред еляет свой ство в о бъекте цели

//--------------------------------------
//_____JavaScript в веб - браузерах___//

//__Основы программирования для веб-сети
//< script src = "scripts/digital_clock. js"></ script >

/* 
<script defer src="deferred. js"></script> - после
заГрузки документа
<script async src="async. js"></script> - дополняться, как только модуль и все его зависимости будут загружены
*/

//Загрузка сценариев по запросу
// Асинхронно загружает и выполняет сценарий из указанного URL.
// Возвращает объект Promise, который разрешается, когда сценарий загружен
function importScript(url) {
  return new Promise((resolve, reject) => {
    let s = document.createElement("script"); // Создать
    // элемент <script>.
    s.onload = () => {
      resolve();
    }; // Разрешить объект Promise,
    // когда сценарий загружен,
    s.onerror = (е) => {
      reject(е);
    }; // Отклонить объект Promise
    //в случае неудачи.
    s.src = url; // Установить URL сценария,
    document.head, append(s); //Добавить <script> в документ
  });
}

//DOM
//отражает древовидную структуру HTML-документа

//Глобальный объект в веб-браузерах
window

//Выполнение программ JavaScript
//-Веб-браузер создает объект Document и начинает синтаксический анализ веб - страницы, добавляя в документ объекты Element и узлы Text по меретого, как он анализирует HTML - элементы
//-встречает элемент < script> , который имеет установленный атрибут
//- DOMContentLoaded и load - инициируется, когда HTML -документ был полностью загружен и синтаксически проанализирован 

//Модель безопасности веб-сети
//- JavaScript не может удалять данные или внедрять вирусы
//-  CORS

//___События
//Зависимые от устройства события ввода - "keydown" 
//Независимые от устройства события ввода - "click"
//События пользовательского интерфейса - "focus", "change"
//События изменения состояни - " load ”
//События, специфичные для API-интерфейса - "waiting" 

//_Регистрация обработчиков событий

//не более одного обработчика для каждого типа событий
//<button onclick=”console.log 'Thank you');”>Please Click</button>

//addEventListener
let b = document.querySelector("#mybutton");
addEventListener(" click ", () => { console.log("Thanks a g a in !"); });
//удаляет функцию обработчика
document.removeEventListener("mouseup", handleMouseUp);
//объект Options - capture(как захватывающий обработчик),  once(автоматически удален после однократного запуска), passiv(никогда не будет вызывать метод preventDefault())
document.addEventListener("click", handleClick, {
  capture: true,
  once: true,
  passive: true
});

//_Вызов обработчиков событий
//вызываются с объектом Event
//- type. Тип события, которое произошло
//- target. Объект, в котором произошло событие
//- currentTarget. Для распространяемых событий это свойство представляет собой объект, в котором был зарегистрирован текущий обработчик событий
//- timestamp  -Отметка времени
//- isTrusted -отправлено самим веб-браузером

//_Контекст обработчика событий
//this ссылается на объект, для которого обработчик был зарегистрирован
//стр 472