console.log("Hello World!");

//------------------------------------
//______Лексическая структура______//

//____Текст программы JavaScript
//язык, чувствительный к регистру символов

//____Комментарии
// Это однострочный комментарий
/*
 * Это многострочный комментарий. Добавочные символы * в начале каждой
 * строки не являются обязательной частью синтаксиса;
 * просто они классно выглядят!
 */

//____Литералы
//значение данных, находящееся прямо в программе
12; // Число двенадцать
1.2; // Число одна целая и две десятых
("hello world"); // Строка текста
("Hi"); // Еще одна строка
true; // Булевское значение
false; // Другое булевское значение
null; // Отсутствие объекта

//____Идентификаторы и зарезервированные слова
//это просто имя ,для именования констант, переменных, свойств, функций и классов.

//____Зарезервированные слова
//вроде if , while и for...

//____Unicode
//математические символы и слова
const n = 3.14;
const si = true;

//___Необязательные точки с запятой
//всегда можете опускать точку с запятой между двумя операторами, если они записаны в отдельных строках
а = 3;
b = 4;
а = 3;
b = 4;

//Защитная ; сохраняет этото ператор отдельным
[х, х + 1, х + 2].forEach(console.log);

//разрыв строки
//return , throw, yield , break и continue

//------------------------------------
//___Типы, значения и переменные____//
//элементарные типы и объектные типы
//Объектные типы JavaScript являются изменяемыми, элементарные типы — неизменяемыми.
//Константы объявляются с помощью co n st, а переменные посредством let(или var в более старом коде JavaScript).

//___Числа
//Number
О;
3;
10000000;

//шестнадцатеричных целочисленных литералов
Oxff; // => 255: (15*16 + 15)
OxBADCAFE; // => 195939070

//целые числа можно также выражать в двоичном (с основанием 2) или восьмеричном (с основанием 8) виде с применением префиксов 0Ь и Оо(или 0В и 00) вместо Ох
0b0101; // => 21: (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
0o377; // => 255: (3*64 + 7*8 + 7*1)

3.14;
2345.6789;
0.333333333333333333;
6.02e23; // 6.02 х 1023
1.4738223e-32; // 1.4738223 х 10'32

//числовых литералах можно применять подчеркивания, чтобы разбивать их на порции
let billion = 1_000_000_000; // Подчеркивание как разделитель тысяч,
let bytes = 0x89_ab_cd_ef; // Подчеркивание как разделитель байтов,
let bits = 0b0001_1101_0111; //Подчеркивание как разделитель полубайтов,
let fraction = 0.123_456_789; // Работает и в дробной части.

//____ Арифметические действия
Math.pow(2, 53); // => 9007199254740992: 2 в степени 53
Math.round(0.6); // => 1.0: округляет до ближайшего целого
Math.ceil(0.6); // => 1.0: округляет в большую сторону до целого
Math.floor(0.6); // => 0.0: округляет в меньшую сторону до целого
Math.abs(-5); // => 5: абсолютная величина
Math.max(x, y, z); // Возвращает наибольший аргумент
Math.min(x, y, z); // Возвращает наименьший аргумент
Math.random(); // Псевдослучайное число х, где 0 <= х < 1.0
Math.PI; // п: длина окружности, деленная на диаметр
Math.E; // е: основание натурального логарифма
Math.sqrt(3); // => 3**0.5: квадратный корень из 3
Math.pow(3, 1 / 3); // => 3** (1/3) : кубический корень из 3
Math.sin(0); // Тригонометрия: также есть Math.cos, Math.atan и т.д.
Math.log(10); // Натуральный логарифм 10
Math.log(100); // Math.LN10 // Десятичный логарифм 100
Math.log(512); // Math.LN2 // Двоичный логарифм 512
Math.exp(3); // Math.E в кубе
//...

//не генерируют ошибки  а возврощает Infinity
1 / 0 - // => Infinity
  1 / 0; // => -Infinity
0 / 0; // => NaN

Number.parselnt(); // То же, что и глобальная функция parselnt
Number.parseFlot();
Number.isNaN(x); // Является ли х значением NaN?
Number.isFinite(x); // Является ли х конечным числом?
Number.islnteger(x); // Является ли х целым числом?
Number.isSafelnteger(х); // Является ли х целым числом -(2**53) < х < 2**

//число не может быть представлено точно
let х = 0.3 - 0.2; // тридцать центов минус двадцать центов
let у = 0.2 - 0.1; // двадцать центов минус десять центов
х === 0.1; // => false: .3-.2 не равно Л

//___Bigint
1234n;
Bigint(Number.MAX_SAFE_INTEGER); // => 9007199254740991n

//Арифметические действия -подобно арифметическим действиям но при деление отбрасывает любой остаток и округляет в меньшую сторону
//смешивать операнды типа Bigintс обычными числовыми операндами нельзя.
//Напротив, операции сравнения работают со смешанными числовыми типами
1000n + 2000n; //=> ЗОООп
1 < 2n; // => true

//___ Дата и время
let timestamp = Date.nowO; //Текущее время как отметка времени (число) .
let now = new Date(); // Текущее время как объект Date.
let ms = now.getTime(); // Преобразовать в миллисекундную отметку времени.
let iso = now.toISOString(); // Преобразовать в строку со стандартным форматом.

//___Текст
// строки являются итерируемымые
// "" '' ``
(""); // Пустая строка: содержит ноль символов
("testing");
("3.14");
('name="myform" ');
("Wouldn’t you prefer 0*Reilly's book?");
"n is the ratio of a circle's circumference to its radius"`"She said 'hi'", he said.`;

// Строка, представляющая две строки, которые записаны в одной строке:
("two\nlines ");

// Однострочная строка, записанная в трех строках:
"опе\
long\
line" // Двухстрочная строка, записанная в двух строках:
`the newline character at the end of this line
is included literally in this string`;

//<button onclick="alert ('Thank you') ">Click Me</button>

//экранирование
("YouVre right, it can*t be a quote");

//\u{1f600} — эмотикон ухмыляющаяся рожица

//конкатенации строк
let msg = "Hello, " + "world"; // Образует строку "Hello, world"

//Строки можно сравнивать с помощью стандартных операций равенств

let s = "Hello, world"; // Начать с некоторого текста.
s.length;
s.substring(l, 4); // => "ell": 2 - й, 3 - й и 4 - й символы
s.slice(1, 4); // => "ell": то же самое
s.slice(-3); // => "rid": последние 3 символа
s.split(", "); // => ["Hello", "world"]: разбивает по строке разделителя
s.indexOf("1"); // => 2: позиция первой буквы
s.lastlndexOf("1"); // => 10: позиция последней буквы 1
s.startsWith("Hell"); // => true: строка начинается с этого
s.endsWith("!"); // => false: s не оканчивается этим
s.includes("or"); // => true: s включает подстроку "or"
s.replace("Но", "уа"); // => "Heya, world"
s.toLowerCase(); // => "hello, world"
s.toUpperCase(); // => "HELLO, WORLD"
s.charAt(0); // => "Н": первый символ
s.charAt(s.length - 1); // => "d": последний символ
"х".padStart(3); // => " х": добавляет пробелы слева до длины 3
"test".trim(); // => "test” : удаляет пробелы в начале и конце
s.concat("!"); // => "Hello, world!” : взамен просто используйте операцию +
"о".repeat(5); // => "<><><><><>” : выполняет конкатенацию

//Не забывайте, что строки в JavaScript неизменяемы,возвращают новые строки: они не модифицируют строку

let s = "hello, world";
s[0]; // => "h”
s[s.length - 1]; // => "d"

//Шаблонные литералы
let name = "Bill";
let greeting = `Hello ${name}.`; // greeting == "Hello Bill

//____регулярные выражение
let text = "testing: 1, 2, 3";
let pattern = /\d+/g;
pattern.test(text); // => true: есть совпадение

//___Булевские значения
//true и false

// false
//undefined null 0 -0 NaN ""// пустая строка

//Все остальные значения true

//Операция && выполняет булевскую операцию "И"
//Операция | | — это булевская операция “ИЛИ”
//! выполняет булевскую операцию НЕ
if ((х === 0 && у === 0) || !(z === 0)) {
  // х и у равны нулю или z не равно нулю
}

//___null и undefined
//null - отсутствие значения
//undefine - не были инициализированы, и то, что получается при запрашивании значений свойств объекта или элементов массива, которые не существуют

//__Тип Symbol
//Чтобы получить значение символа, понадобится вызвать функцию Symbol (), которая никогда не возвращает то же самое значение дважды, даже когда вызывается с таким же аргументом.
let strname = "string name";
let symname = Symbol("propname");
let о = {};
о[strname] = 1;
о[strname]; // => 1: доступ к свойству со строковым именем

toString(); //— единственный интересный метод в экземплярах Symbol
let s = Symbol("sym_x");
s.toString(); // => "Symbol(sym_x) "

//Symbol.for() всегда возвращает то же самое значение
let s = Symbol.for("shared");
let t = Symbol.for("shared");
s === t; // => true
s.toString(); // => "Symbol (shared) "
Symbol.keyFor(t); // => "shared"

//__ Глобальный объект
//его свойствами являются глобально определенные идентификаторы, доступные программе JavaScript
//Node - global
//Window
//ссылки на глобальный объект - globalThis

//___Неизменяемые элементарные значения и изменяемые объектные ссылки
//Элементарные значения неизменяемый
//Объекты отличаются от элементарных значений. Прежде всего, они изменяемы — их значения можно модифицировать
let о = { х: 1 };
о.х = 2;
о.у - 3;
let а = [1, 2, 3];
а[0] = 0;
а[3] = 4;

let о = { х: 1 },
  р = { х: 1 }; // Два объекта с одинаковыми свойствами
о === р; // => false: отдельные объекты никогда не равны

// объекты называют ссылочными типами они ссылаются на тот же самый внутренний объект
let а = []; // Переменная а ссылается на пустой массив
let b = а; // Теперь на тот же самый массив ссылается переменная b
b[0] = 1; // Изменить массив, на который ссылается переменная b
а[0]; // => 1: изменение также будет видимым через переменную а
а === b; // => true: а и b ссылаются на тот же самый объект,поэтому они равны

//Если вы хотите создать новую копию объекта или массива, тогда должны явно скопировать свойства объекта или элементы массива
let a = ["а", "b", "с"]; // Массив, который мы хотим скопировать
let b = []; // Отдельный массив, куда м ы будем копировать
for (let i = 0; i < a.length; i++) {
  // Для каждого из всех индексов
  b[i] = a[i]; // Копировать элемент а в b
}

let с = Array.from(b); //В ES6 копируйте массивы с помощью Array.from()

function equalArrays(а, b) {
  if (а === b) return true; // Идентичные массивы равны
  if (a.length !== b.length) return false; //Массивы разного размера
  //не равны
  for (let i = 0; i < a.length; i++) {
    //Цикл по всем элементам
    if (a[i] !== b[i]) return false; //Если любые элементы отличаются,
    //то массивы не равны
  }
  return true; // Иначе они равны
}

//___Преобразования типов
"7" + "4"; //11
10 + " objects"; // => ”10 objects": число 10 преобразуется в строку

//___Преобразования и равенство
null == undefined; //=> true: эти два значения трактуются как равные,
"0" == 0; //=> true перед сравнением строка преобразуется в число.

//___Явные преобразование
Number("3"); // => 3
String(false); // => "false"
Boolean([]); // => true

let n = 17;
let binary = "Ob" + n.toString(2); // binary == "OblOOOl

let n = 123456.789;
n.toFixed(0); // => "123457"

//___неявное преобразование
х +
  "" + // => String(х)
  х; // => Number (х)
х - 0; // => Number (х)
!!х; // => Boolean(х) : обратите внимание на два символа !

parselnt("-12.34"); // => -12
parseFloat(" .1")(
  // = > 0.1

  //___ Преобразования объектов в элементарные значения
  //prefer-string toString() /  prefer-number valueOf() /  no-preference
  { х: 1, у: 2 }
).toString(); // => "[object Object]”
let d = new Date(2010, 0, 1); //1 января 2010 года (тихоокеанское время)
d.valueOf(); // => 126233280

//___Объявление и присваивание переменных
// let / const
//const только для значений, которые не должны изменяться
let i = 0,
  j = 0,
  k = 0;

//Переменные и константы, объявленные с помощью let и const, имеют блочную область видимости(if / else /while / for)
const х = 1; //О бъявить х как глобальную константу
if (х === 1) {
  let х = 2; //В н утр и блока х может ссылаться на другое значение
  console.log(х); // Выводится 2
}
console.log(х); //В ы водится 1: мы снова вернулись  в глобальную область видимости
let х = 3; //ОШИБКА! Синтаксическая ошибка при попытке
//п о в т о р н о го объявления х

//var
//функциональная видимость

//___Деструктурирующее присваивание
let [х, у] = [1, 2]; // То же, что и l e t х = 1, у = 2
[X, у] = [х + 1, у + 1]; // То же, что и х = х + 1, у = у + 1

let о = { х: 1, у: 2 }; // Объект, по которому будет
// делаться проход в цикле
for (const [nаше, value] of Object.entries(о)) {
  console.log(nаше, value);
}

let [х, у] = [1]; // х == 1; у == u n d efin ed
[х, у] = [1, 2, 3]; // х == 1; у == 2

let [х, ...у] = [1, 2, 3, 4]; // у == [2, 3, 4]

let [а, [Ь, с]] = [1, [2, 2.5], 3]; // а == 1; b == 2; с ==

let [first, ...rest] = " Hello ";

let transparent = { г: 0.0, g: 0.0, b: 0.0, а: 1.0 }; // Цвет RGBA
let { г, g, b } = transparent; // г = 0 .0; g == 0 .0; b == 0 .0

const sin = Math.sin,
  cos = Math.cos,
  tan = Math.tan;
const { sin, cos, tan } = Math;

const { cos: cosine, tan : tangent } = Math;

let points =[{ х: 1, у: 2 }, { х: 3, у: 4 }];
let [{ х: x1, у: у1 }, { х: х2, у: у2 }] = points

//----------------------------------------
//_________Выражения и операции________//
