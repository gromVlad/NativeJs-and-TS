// ___lesson 3__
// Eventlistener - функция при котрором изменяеться состояние
// callback => вызов обратной функции (она вызваеться не нами а тем кому мы делигируем решать этот вопрос) , методы массива, setTimeout .. , обработка событий в браузере (слушатель, обработчик, подписчик) / handler, listener,subsriber
// сам event -> объект который содержит сведения об объекте
// по умолчанию в нашу функцию передаем значения event

//find on id (id = "small")
const sm = document.getElementById('small')

//create element
//document.createElement('')

//callback 
const handler = () => {
  alert('click')
}
const handler2 = () => {
  alert('click')
}
sm.onclick = handler
//переназначили свойтсва / это свойство только хранит одно значения
sm.onclick = handler2

//несколько событий сразу  к одному элементу
sm.addEventListener('click',handler)
sm.addEventListener('click',handler2)
sm.addEventListener('click', () => alert ('hey'))

//cнять обработчик
sm.removeEventListener(handler)
//чтобы удалить анонимную функци. надо ее сначало кому нибудь присвоить а далее уже удалить (тяжело удалить)
const handler3 = () => alert('hey')
sm.removeEventListener(handler3)

const handler4 = (e) => console.log(e)//objects - key:value -> получили информацию обо всех методах и свойствах его.Дальше через точечный вызов вызвать эти методы.

//!!!Событие наше при работе как бы погружаеться в DOM дерево.А далее всплытие. 99% мы ловим всплытие.
const md = document.getElementById('medium')
const bd = document.getElementById('big')
md.addEventListener(handler2)
bd.addEventListener(handler2)
//сначало получили целевой элемент и у нас на которое наше событие при всплтии дергать другие события
//елемент который сгенировал события будет e.target/ currentarget это тот элемент который вызвал обработчик событие (target - это как место рождения , currentarget - это место проживание оно может быть разным - > по мере всплытие будет вызвать все обработчики на пути и как только он вызовет элемент он попадает в свойство currentarget)

sm/addEventListener('click', (e) => {
  //используем чтобы для конкретного элемента остановить событие о она не работала при всплытии / отключаем его
  e.stopPropagation()

  if (e.currentTarget.id === "small"){
    alert('hello')
  }
})

//!!!если будет как нибудь вложеность в дальнейшем то может все поломаться в target поэтому используем всегда currentarget

//!!! для улучшения быстройдествия системы с помощью оптимизации событий -придумали подход делегирование обработки события родительскому элементу.Тоесть делегируем обработку событий родитлю и уже через него обращаемся к нужному элементу а не создаем в каждом элементе свой обработчик и для этого ам шужно свойство target.Подход в reacte не особо такой используеться так как не делиться на компонеты а все работает через родителя, но раньше использовали т.к системы были не особо мощные
sm.addEventListener('click', (e) => {
  if (e.target.id === 'Button'){
    alert(e.target.id)
  }
})

//по дефолту ссылка и форма также имеют обработчики(перевод или перегазрузка), если хотим не использовать их дефолтные события
sm.addEventListener('click', (e) => {
  e.preventDefault()
  alert('Hello')
})

//также есть pointerevants и т.д в css с помощью которых также можно событие в css изменять выключать и т.д.