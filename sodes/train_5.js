//_________React Interview Questions_________//

//JSX -> JS (React.createElement('div')) -> далее создает виртуальный DOM а на базе него создаеться DOM 

//---------
//При перерисовке компоненты прошлый виртуальный DOM сохроняеться и создаеться новый если изменении нету то DOM  не изменяем т.к не произошли изменения 

//--------
//У нас есть componentsShotsUpdate() жизненый цикл отвечает на вопрос должна ли компонента вызвать render render заставляет перерисовывать DOM (componentsShotsUpdate() старая версия)

//----------
//server -side rendering -> html генерируеться на сервере
//Server-side rendering - это подход, при котором HTML страница генерируется на стороне сервера, а затем отправляется клиенту. В противоположность подходу, при котором HTML генерируется в браузере после загрузки страницы.
/* Преимущества server-side rendering:
Лучшая SEO - поисковые роботы видят генерированный HTML, а не пустую страницу.
Быстрее открытие страницы - HTML уже готов, не нужно ждать пока сгенерирует его JavaScript в браузере.
Лучшая совместимость - не зависит от JavaScript в браузере.
Недостатки:
Сложнее реализовать - требует бекенда, который будет генерировать HTML.
Больше нагрузки на сервер - сервер должен генерировать HTML для каждого клиента. */

//-------
//unit derection data flower
//Unit testing - это тестирование отдельных замкнутых функций или частей программы.
//По сути, unit direction data flower testing - это unit testing, при котором тестовые данные хранятся в отдельном источнике данных.
/* Преимущества такого подхода:
Отделение тестов от тестового кода. Тестовый код становится проще и чище.
Легко добавлять новые тестовые данные.
Легко менять тестовые данные.
Возможность использовать одни и те же данные для разных тестов. */
//Обычно тестовые данные хранятся в тестовом файле, например:
//test - data.json:
[
  {
    "name": "John",
    "age": 30
  },
  {
    "name": "Jane",
    "age": 25
  }
]
//Тестовый код:
function testPerson(data) {
  const actual = calcAge(data.age);
  const expected = data.age + 1;
  assertEquals(actual, expected);
}
// Используем данные
testPerson(testData[0]);
testPerson(testData[1]);
//Таким образом тестовый код становится проще, легче дополнять и тестовые данные, и сам тестовый код.

//------
/* Однонаправленный поток данных (unidirectional data flow) - это ключевой принцип работы React. Он заключается в следующем:
Все данные текущего состояния приложения хранятся в верхнем компоненте - обычно это Root component.
Компоненты-потомки получают данные и функции обновления состояния по props от своих родителей.
Когда происходит обновление состояния, компонент корневого уровня обновляется первым.
Затем обновляются его потомки, которые получают новые props.
Потомки не могут непосредственно изменять состояние родителя, они могут лишь подать запрос на обновление с помощью переданных функций.
Схематично это выглядит так:
Root → Child1 → Child2 → Child3
Если произойдет обновление:
Обновляется состояние root
Root перерисовывается
Child1 получает новые props и перерисовывается
Child2 получает новые props и перерисовывается
И т.д.
Это позволяет реализовать следующее:
Простота трассировки: всегда можно понять, откуда пришли данные в компонент.
Легкое тестирование: компоненты можно тестировать изолировано.
Функциональность компонентов: каждый контролирует только свою часть 
В ангуляре двунапрвленный биндинг данныx*/

//---------
//Babel компилирует JSX в js

//-------
//Props - это свойства, которые передаются в компонент React. Они используются для передачи данных от родительского компонента к дочернему.

//------
/* Локальный стейт (local state) - это состояние, хранимое внутри компонента React.
Компонент управляет и обновляет свой собственный стейт.
Мы используем локальный стейт, когда данные зависят только от компонента. */

//-------
//Сам по себе react не перерисовываться , только в одном случае если изменяються сами компоненты локально это тупо функциональность react, state меянет только функция reduser

//---------
/* Жизненные циклы (life cycle) - это последовательность методов, которые вызываются в разные этапы "жизни" компонента React.

Основные этапы жизненного цикла компонента:

- Mounting (компонент смонтирован):
  - constructor
  - getDerivedStateFromProps
  - render
  - componentDidMount

- Updating (компонент обновляется):
  - getDerivedStateFromProps  
  - shouldComponentUpdate
  - render  
  - getSnapshotBeforeUpdate  
  - componentDidUpdate

- Unmounting (компонент размонтирован):
  - componentWillUnmount

Каждый этап позволяет выполнять разные действия:

- constructor - инициализация стейта компонента.
- render - рендерит JSX.
- componentDidMount - после маунта, хорошо подходит для AJAX запросов. Компонента отрисовалось
- shouldComponentUpdate - определяет нужно ли обновлять компонент. 
- componentDidUpdate - после обновления компонента.
- componentWillUnmount - перед размонтированием, хорошо отменять подписки.

Это позволяет иметь полный контроль над "жизнью" компонента.

Например, мы можем:

- Инициализировать стейт в constructor.
- Загрузить данные после маунта в componentDidMount.
- Оптимизировать обновление компонента в shouldComponentUpdate. 
- Отменить подписки перед размонтированием в componentWillUnmount.

Жизненные циклы являются важной частью работы с компонентами React. */

//---------
//Полифилы - реализация старых фич в новых версиях

//----------
//Данные по правилам react нельзя хранить в input 

//----------
//autoFocus - это свойство HTML элементов, которое позволяет автофокусировать элемент после рендера.
<input type="text" autoFocus />

//---------
/* HOC (High Order Component) - это функция, которая принимает компонент и возвращает новый компонент с дополнительной функциональностью.
HOC позволяет переиспользовать логику компонента. */
function withLogging(Component) {
  return class extends React.Component {
    componentDidMount() {
      console.log('Component mounted');
    }
    componentWillUnmount() {
      console.log('Component unmounted');
    }
    render() {
      return <Component {...this.props} />
    }
  }
}

const Button = props => {
  return <button>{props.text}</button>
}
const ButtonWithLogging = withLogging(Button);
<ButtonWithLogging text="Click me" />

//---------
//connect - это функция из библиотеки react-redux, которая позволяет подключать компоненты React к Redux стору.
import { connect } from 'react-redux';

const Counter = ({ count, increment }) => (
  <div>
    <h2>Count: {count}</h2>
    <button onClick={increment}>Increment</button>
  </div>
)
const mapStateToProps = state => ({
  count: state.count
})
const mapDispatchToProps = {
  increment: incrementCount
}
const CounterContainer = connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter)
export default CounterContainer;

//----------
/* Пурые (Pure) компоненты - это такие компоненты React, которые выполняют своё обновление (перерисовку) только при изменении входных пропсов (props).
Это означает, что если пропсы не поменялись - компонент не будет перерендерен. */
// Обычный компонент
class Example extends React.Component {
  render() {
    return <div />
  }
}
// Пурый компонент
class Example extends React.PureComponent {
  render() {
    return <div />
  }
}
/* React.PureComponent переопределяет shouldComponentUpdate и производит shallow comparison пропсов и стейта.

Преимущества пурых компонентов:

Быстродействие. Избегаются лишние перерендеры.
Оптимизация производительности.
Недостатки:

Не обновляют стейт, если пропсы не изменились.
Лишь shallow comparison, не работает со сложными структурами данных.
Таким образом, если в вашем компоненте:

Пропсы не меняются часто
Лишние перерендеры замедляют работу
То стоит рассмотреть использование PureComponent. Это простой, но эффективный оптимизационный ход.

Кроме того, подходят для функциональных компонентовmemo(). */

