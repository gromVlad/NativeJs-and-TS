// Big O_ Intro
//способ математический выяснить какой из код более эффективнго по времени и пространственной сложности его работы. Определения эффективности кода по сложности а точнее по количество операции, с помощью big O измеряем пространтвенную сложность. Сложность - это объем памяти который что-то использует.Но обычно концетрируемся на временной сложности

//-----------------------
//Worst Case
//лучший кейс обозначаеться амего
//средний кейс работы - тэта
//худший кэйс омикрон (Big O) , и когда мы измеряем большое О то мы по умолчанию берем худший случай

//------------------
// O(n)
//пропрционально любому значению если количество итерации 10 то и на выходе то же 10, на графике прямая линия(ось x - n, y - количество операции )
function bigO(n) {
  for (let index = 0; index < n; index++) {
    console.log(index);
  }
}
bigO(10)//0 1 2 3 4 5 6 7 8 9

//------------------
//O(n) с константой
function bigO(n) {
  for (let index = 0; index < n; index++) {
    console.log(index);
  }
  for (let index2 = 0; index2 < n; index2++) {
    console.log(index2);
  }
  
}
bigO(10)//0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
//n + n = 2n - все равно отбрасываем константу (2) хоть 100n и по факту будет O(n)

//---------------------
//O(n2) 
//идет на увелечения количество операции , n растет очень медленно
function bigO(n) {
  for (let index = 0; index < n; index++) {
    for (let index2 = 0; index2 < n; index2++) {
      console.log(index,index2);
    }
  }
}
bigO(9) // 0 01 02 ... 99
//n * n = n2
//можно еще вложить следующий цикл 3 и будет 001 ... 999 , n * n * n = n3. Но все равно принято писать n2
 
//----------------------
//drop non - dominants
function bigO(n) {
  for (let index = 0; index < n; index++) {
    for (let index2 = 0; index2 < n; index2++) {
      console.log(index, index2);
    }
  }

  for (let index3 = 0; index < n; index3++) {
    console.log(index3);
  }
}
bigO(9) // 0 01 02 ... 99 0...9
//O (n2) +  O(n) , n2 являеться доминируещим поэтому n отбрасваеться и сотаеться O (n2)

//-------------------
//0 (1)
//чтобы не было количество операции не меняеться 
//самый эффективный способ, прямая линия по n количество операции минимально
function bigOne(n) {
  console.log(n + n);
  //console.log(n + n + n);
  //console.log(n + n + n + n);
}
bigOne(2)//4
//bigOne(2)//6
//bigOne(2)//8
//независемо от количество операция не меняеться , их не становиться больше

//--------------------
//0(log n)
//log (2) 8 = 3 (2 в 3 = 8)
//техника разделяй и властвуй, когда мы постоянно делим например массив на части пока не найдем необходимое значения
//не так эффективно как O(1) но проходит минимальное число операции

//--------------------
//Различные термины для входных данных
function bigO(a,b) {
  for (let index = 0; index < a; index++) {
    console.log(index);
  }
  for (let index2 = 0; index2 < b; index2++) {
    console.log(index2);
  }
}
bigO(5,9)// 0 1 2 3 4 0 1 2 3 4 5 6 7 8
// O (a + b) = O(14) 

//анологично мы также будет дейстововать и с вложенными друг в друга циклам
function bigO(a,b) {
  for (let index = 0; index < a; index++) {
    for (let index2 = 0; index2 < b; index2++) {
      console.log(index, index2);
    }
  }
}
// O (a * b) = O(45) 

//--------------------
//Array
//[45,98,12] index -> [0,1,2]

//push() и pop() -> O(1) т.к. представляет собой одну операцию сначало добовления конца элемента и потом его удаления

//shift() unshift() -> O(n) приходиться передвигать элементы при добовлении или удалении в начале массива.Придеться индексировать элементы все повторно

//!если ищем по значению то это O(n).
//!если ищем по индексу то это O(1)

//-------------------
//Сравнение одно и другой операции
//если n = 100 
//0(1) = 1 (постоянное время)
//o(log n) = 7 (разделяй и властвуй)
//o(n) = 100 (пропорционально)
//o(n2) = 10000 (цикл в цикле)

//https://www.bigocheatsheet.com/ -сайт шпора по алгоритмам

//лучший способ научиться программировать это программировать )))

//-------------------
//Classes
class Cookie {
  constructor(color){
    this.color = color
  }

  getColor(){
    console.log(this.color);
  }

  setColor(color){
    return this.color = color
  }
}

//instance (экземпляр класса)
let cookieOne = new Cookie('blue')
let cookieTwo = new Cookie('green')
cookieOne.getColor()//blue
cookieTwo.getColor()//green
cookieOne.setColor('red')
console.log(cookieOne);//Cookie {color: 'red'}

//------------------------
//pointers

let n1 = 5
let n2 = n1 // делаем число равным 5 в момент объявления переменной, и если мы изменим n1 = 10 все равно n2 будет 5

//указатели на один и тот же объект в памяти
let obj1 = {
  value:11
}
let obj2 = obj1
